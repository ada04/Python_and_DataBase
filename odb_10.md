# under construction

# 10. Управление транзакциями
Транзакция базы данных — это группа SQL-операторов, которые вносят логические изменения в базу данных. Когда операторы, такие как Cursor.execute()INSERT Cursor.executemany()или UPDATE, выполняют SQL-операторы, такие как INSERT или UPDATE, транзакция запускается или продолжается. По умолчанию python-oracledb не фиксирует эту транзакцию в базе данных. Вы можете явно зафиксировать или откатить её, используя методы Connection.commit()и Connection.rollback(). Например, для фиксации новой строки:

cursor = connection.cursor()
cursor.execute("insert into mytab (name) values ('John')")
connection.commit()
Транзакции обрабатываются на уровне соединения, то есть изменения, выполненные всеми курсорами, полученными из соединения, будут зафиксированы или откатены одновременно.

Когда соединение с базой данных закрывается, например, с помощью Connection.close(), или когда переменные, ссылающиеся на соединение, выходят из области действия, любая незафиксированная транзакция будет откачена.

При выполнении операторов языка определения данных (DDL) , таких как CREATE, Oracle Database всегда выполняет фиксацию.

В этой главе рассматривается модель синхронного программирования python-oracledb. Сведения об управлении транзакциями в асинхронных соединениях см. в разделе « Управление транзакциями с использованием асинхронных методов» .

10.1. Автоматическая фиксация
Альтернативный способ фиксации — установить атрибут Connection.autocommitсоединения в значение True. Это гарантирует фиксацию всех операторов DML (INSERT, UPDATE и т. д.) по мере их выполнения. В отличие от Connection.commit(), это не требует дополнительного обращения к базе данных, поэтому при правильном использовании этот метод более эффективен.

При выполнении нескольких операторов DML, составляющих одну транзакцию, рекомендуется использовать режим автоподтверждения только для последнего оператора DML в последовательности операций.

Предупреждение

Злоупотребление этим режимом может повлиять на производительность базы данных. Кроме того, он может нарушить согласованность реляционных данных, когда связанные изменения, внесённые в несколько таблиц, фиксируются независимо, что приводит к рассинхронизации данных в таблицах.

Обратите внимание, что независимо от значения autocommit, Oracle Database всегда фиксирует открытую транзакцию при выполнении оператора DDL.

В примере ниже показано добавление нового клиента в таблицу CUST_TABLE. Соответствующая SALESтаблица обновляется покупкой 3000 ручек этим клиентом. Последняя вставка использует режим автофиксации для фиксации обеих новых записей:

# Add a new customer
id_var = cursor.var(int)
connection.autocommit = False  # make sure any previous value is off
cursor.execute("""
        INSERT INTO cust_table (name) VALUES ('John')
        RETURNING id INTO :bvid""", bvid=id_var)

# Add sales data for the new customer and commit all new values
id_val = id_var.getvalue()[0]
connection.autocommit = True
cursor.execute("INSERT INTO sales_table VALUES (:bvid, 'pens', 3000)",
        bvid=id_val)
10.2 Явные транзакции
Метод Connection.begin()можно использовать для явного запуска локальной или глобальной транзакции.

Без параметров эта команда явно начинает локальную транзакцию; в противном случае это явно начинает распределённую (глобальную) транзакцию с заданными параметрами. Подробнее см. в документации Oracle.

Обратите внимание, что для использования глобальных (распределенных) транзакций необходимо задать атрибуты Connection.internal_nameи свойства.Connection.external_name

10.3 Распределенные транзакции
Информацию о распределенных транзакциях см. в главе Использование двухфазных фиксаций (TPC) .

10.4. Транзакции без сеанса
Бессеансовая транзакция — это транзакция, которую можно приостанавливать и возобновлять в течение её жизненного цикла. Она разрывает связь между транзакциями и соединениями, то есть транзакция больше не привязана к конкретному соединению. Это позволяет освобождать соединения для использования другими пользователями, в то время как транзакция остаётся открытой и может быть возобновлена ​​позже. При использовании бессеансовых транзакций вам не нужно использовать менеджер транзакций, поскольку координацией транзакций управляет Oracle AI Database.

Транзакции без сеансов поддерживаются как в тонком, так и в толстом режимах python-oracledb. Требуется Oracle AI Database 26ai (или более поздней версии). Для толстого режима python-oracledb дополнительно требуется Oracle Client 23.6 (или более поздней версии).

Каждая транзакция без сеанса идентифицируется уникальным идентификатором. Он может быть выбран пользователем или сгенерирован python-oracledb.

Бессессионные транзакции идеально подходят для интерактивных приложений, требующих времени на обдумывание пользователем. Если один пользователь запускает транзакцию в базе данных, а затем не выполняет операции с ней в течение некоторого времени (так называемого «времени на обдумывание»), транзакция может быть приостановлена, а соединение с базой данных может быть освобождено и использовано другим пользователем. Когда первый пользователь будет готов продолжить работу, можно установить соединение с базой данных и возобновить транзакцию. Без бессессионных транзакций обоим пользователям потребовались бы отдельные соединения на протяжении всего взаимодействия с системой, включая время на обдумывание.

С помощью python-oracledb вы можете:

Запустить транзакцию без сеанса в соединении с базой данных, указав уникальный идентификатор транзакции

Выполнение операций с базой данных в транзакции

Приостановить транзакцию в соединении после завершения операций с базой данных

Возобновите транзакцию в том же соединении или в другом соединении, используя тот же идентификатор транзакции.

Зафиксировать или откатить транзакцию в том же соединении или в другом соединении, если транзакция была приостановлена ​​предыдущим соединением.

Бессеансовые транзакции можно использовать во всех базах данных Oracle, включая Oracle Real Application Clusters (RAC) . Для баз данных RAC можно запустить и приостановить бессеансовую транзакцию на одном экземпляре базы данных RAC и возобновить её на другом экземпляре базы данных RAC. Чтобы зафиксировать или откатить бессеансовую транзакцию, она должна быть активна только на одном из экземпляров RAC. Если эта бессеансовая транзакция активна на нескольких экземплярах RAC, сервер базы данных ожидает в течение времени DISTRIBUTED_LOCK_TIMEOUT, чтобы позволить другим экземплярам приостановить эту транзакцию, прежде чем продолжить её фиксацию или откат.

Обратите внимание на некоторые ограничения при использовании безсеансовых транзакций. Откат к точке сохранения безсеансовой транзакции в предыдущем соединении невозможен. Безсеансовые транзакции не могут быть преобразованы в распределённые транзакции . Состояния сеанса, такие как все параметры, установленные командой ALTER SESSION, временные состояния LOB-объектов и состояния PL/SQL, не переносятся в новое соединение. Подробнее о других ограничениях см. в разделе « Ограничения для безсеансовых транзакций» .

Дополнительную информацию о бессеансовых транзакциях см. в разделе « Разработка приложений с бессеансовыми транзакциями» в руководстве Oracle Database Development Guide.

10.4.1 Запуск транзакций без сеанса
Чтобы начать транзакцию без сеанса, используйте Connection.begin_sessionless_transaction(), например:

txn_id = b"new_sessionless_txn"
connection.begin_sessionless_transaction(transaction_id=txn_id, timeout=120,
    defer_round_trip=False)
Вы можете передать следующие параметры Connection.begin_sessionless_transaction():

transaction_id: Этот параметр представляет собой уникальный идентификатор транзакции, используемый для управления ею от начала до конца. Если значение не указано , функция генерирует и возвращает transaction_idуникальный универсальный идентификатор (UUID)begin_sessionless_transaction() . Пример: «36b8f84d-df4e-4d49-b662-bcde71a8764f».

timeout: этот параметр определяет количество секунд, в течение которых транзакция может оставаться приостановленной при Connection.suspend_sessionless_transaction()последующем вызове, или если транзакция автоматически приостановлена, если suspend_on_successпараметру присвоено значение True в Cursor.execute()или Cursor.executemany(). Значение по умолчанию — 60 секунд. Если транзакция не возобновится в течение указанного времени, она будет откачена.

defer_round_trip: этот параметр определяет, следует ли отправлять запрос на запуск безсеансовой транзакции немедленно или со следующей операцией с базой данных. Значение по умолчанию — False , то есть запрос отправляется немедленно. Если установлено значение True , запрос отправляется со следующей операцией с базой данных в данном соединении, что сокращает количество обращений к базе данных.

После запуска транзакции все операторы SQL выполняются как ее часть.

Транзакция без сеанса активна с момента ее нового запуска или возобновления до момента ее приостановки, подтверждения или отката.

10.4.2 Приостановка бессеансовых транзакций
После выполнения операций с базой данных активная бессеансовая транзакция может быть явно приостановлена ​​или, при необходимости, автоматически приостановлена ​​при следующей операции с базой данных, если операция выполнения завершится успешно. Это отсоединяет транзакцию от текущего соединения.

Явная приостановка транзакций

Чтобы явно приостановить активную транзакцию, используйте Connection.suspend_sessionless_transaction():

connection.suspend_sessionless_transaction()
Это приостанавливает активную транзакцию. Эта транзакция больше не привязана к соединению.

Приостановка транзакции после операции с базой данных

Чтобы автоматически приостановить активную транзакцию после следующей операции с базой данных, установите suspend_on_successпараметр в значение True в Cursor.execute()или Cursor.executemany(). Эта настройка приостанавливает транзакцию, если выполненный оператор или блок PL/SQL завершается успешно. Это помогает сократить количество обращений к базе данных, что, в свою очередь, повышает производительность. Например:

# Suspend after execute
cursor.execute(
    "insert into slt_table (name) values ('John')",
    suspend_on_success=True
)
После приостановки транзакции дальнейшие операции с базой данных не являются частью этой транзакции до тех пор, пока она не будет возобновлена.

Если операция выполнения вызовет исключение, транзакция не будет приостановлена.

Если активных транзакций без сеанса нет, этот параметр игнорируется.

10.4.3 Возобновление транзакций без сеанса
Чтобы возобновить приостановленную бессессионную транзакцию, используйте Connection.resume_sessionless_transaction(), например:

connection.resume_sessionless_transaction(transaction_id=txn_id, timeout=80,
  defer_round_trip=False)
Параметр transaction_idдолжен содержать идентификатор существующей транзакции.

Вы можете установить следующие параметры в Connection.resume_sessionless_transaction():

timeout: Этот параметр указывает, как долго данное соединение должно ожидать возобновления безсеансовой транзакции, если оно в данный момент используется другим соединением. В этом случае текущее соединение ожидает приостановки транзакции в течение этого времени ожидания. Если транзакция остаётся занятой другим соединением по истечении времени ожидания, возникает ошибка ORA-25351 . Если другое соединение завершает транзакцию, возникает ошибка ORA-24756 . Эти сообщения об ошибках выдаются только для экземпляров без RAC. Сведения об использовании Oracle RAC см. в разделе Безсеансовые транзакции с Oracle RAC .

defer_round_trip: Этот параметр определяет, следует ли отправлять запрос на возобновление безсеансовой транзакции немедленно или со следующей операцией с базой данных. Значение по умолчанию — False , то есть запрос отправляется немедленно. Если установлено значение True , запрос отправляется со следующей операцией с базой данных в данном соединении, что сокращает количество обращений к базе данных.

После возобновления транзакция считается активной, а операции с базой данных являются частью этой транзакции.

10.4.4. Подтверждение или откат бессессионных транзакций
Новая или возобновленная транзакция может быть зафиксирована с помощью Connection.commit() и откачена с помощью Connection.rollback().

После подтверждения или отката транзакция завершается и не может быть возобновлена, приостановлена ​​или использована для дополнительных операций с базой данных.

10.4.5 Пример использования транзакций без сеанса
Пример использования транзакций без сеанса:

import oracledb

connection1 = oracledb.connect(user="hr", password=userpwd, dsn="localhost/orclpdb")

txn_id = b"sessionless_txnid"
cursor1 = connection1.cursor()

cursor1.execute("create table sessionlessTxnTab (id number, name varchar2(50))")

# Start a new sessionless transaction
connection1.begin_sessionless_transaction(transaction_id=txn_id, timeout=15)

# Execute a database operation
cursor1.execute("insert into sessionlessTxnTab values(1, 'row1')")

# Insert another row
cursor1.execute("insert into sessionlessTxnTab values(2, 'row2')")

# Suspend the sessionless transaction
connection1.suspend_sessionless_transaction()

result = cursor1.execute("select * from sessionlessTxnTab")
rows = result.fetchall()
print(rows)
connection1.close()
В приведённом выше примере транзакция не фиксируется перед приостановкой. Поэтому вставленные данные не будут видны, и это будет выводиться []в качестве результата.

Транзакция txn_id имеет тайм-аут 15 секунд, в течение которого она должна быть успешно возобновлена ​​через другое соединение. В примере ниже транзакция возобновляется через другое соединение. Необходимо использовать тот же идентификатор транзакции:

# Resume the transaction in another connection
connection2 = oracledb.connect(user="hr", password=userpwd, dsn="localhost/orclpdb")
connection2.resume_sessionless_transaction(transaction_id=txn_id)

cursor2 = connection2.cursor()
cursor2.execute("insert into sessionlessTxnTab values(3, 'row3')")

connection2.commit()

result = cursor2.execute("select * from sessionlessTxnTab")
rows = result.fetchall()
print(rows)
В результате будет выведен следующий вывод (включая строки, вставленные в первый фрагмент кода):

[(1, 'row1'), (2, 'row2'), (3, 'row3')]
10.4.6 Просмотр транзакций без сеанса
Представление Oracle Database V$GLOBAL_TRANSACTION отображает информацию о текущих активных транзакциях на сервере базы данных.

Чтобы просмотреть активную транзакцию в текущем соединении, вы можете использовать следующий запрос с NVL() :

SELECT NVL(dbms_transaction.get_transaction_id, 'NULL transactionId')
FROM dual;
Функция GET_TRANSACTION_ID пакета DBMS_TRANSACTION возвращает идентификатор транзакции, используемый в текущем соединении.
