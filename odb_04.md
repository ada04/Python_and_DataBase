# В разработке

# 4. Подключение к базе данных Oracle
Соединения между python-oracledb и Oracle Database используются для выполнения SQL и PL/SQL , для вызова функций SODA , для получения уведомлений и сообщений базы данных , а также для запуска и остановки базы данных.

В этой главе рассматривается модель синхронного программирования python-oracledb. Подробнее об асинхронном программировании см. в разделах « Параллельное программирование с использованием asyncio» и «Конвейеризация» .

По умолчанию python-oracledb работает в «тонком» режиме, который подключается напрямую к Oracle Database. В этом режиме клиентские библиотеки Oracle не требуются. Однако при их использовании доступны некоторые дополнительные функции . Python-oracledb работает в «толстом» режиме, когда используются клиентские библиотеки Oracle. См. раздел «Включение толстого режима python-oracledb» . Оба режима обладают полной функциональностью, поддерживающей спецификацию Python Database API v2.0.

Если вы планируете использовать режим Thick, необходимо вызвать приложение init_oracle_client()до создания любого отдельного соединения или пула. В режиме Thick python-oracledb загружаются клиентские библиотеки Oracle, которые взаимодействуют с существующей базой данных через Oracle Net. Клиентские библиотеки Oracle необходимо установить отдельно. См. раздел Установка python-oracledb . Oracle Net — это не отдельный продукт, а способ взаимодействия клиента Oracle и базы данных Oracle.

Существует два способа создания подключения к Oracle Database с помощью python-oracledb:

Отдельные соединения : Отдельные соединения полезны, когда приложению требуется одно соединение с базой данных. Подключения создаются вызовом oracledb.connect(). Для asyncio используйте oracledb.connect_async()вместо него, см. раздел «Асинхронное подключение к базе данных Oracle» .

Объединение подключений в пул : пулы подключений важны для производительности, когда приложения часто подключаются к базе данных и отключаются от неё. Пулы поддерживают функции высокой доступности Oracle и рекомендуются для приложений, которым требуется надёжность. Небольшие пулы также могут быть полезны для приложений, которым требуется несколько подключений для нечастого использования. Пулы создаются во oracledb.create_pool()время инициализации приложения, а затем ConnectionPool.acquire()могут быть вызваны для получения соединения из пула. Для asyncio вместо этого используйте oracledb.create_pool_async() и AsyncConnectionPool.acquire(), см. раздел Пулы подключений .

Многие параметры подключения можно контролировать с помощью параметров подключения python-oracledb. Другие параметры можно настроить в дополнительных файлах конфигурации Oracle Net или в дополнительном файле конфигурации клиента Oracle . К ним относятся ограничение времени открытия соединения и включение сетевого шифрования .

4.1. Отдельные соединения
Отдельные соединения — это соединения с базой данных, которые не используют пул соединений python-oracledb. Они полезны для простых приложений, использующих одно соединение с базой данных. Простые соединения создаются путём вызова oracledb.connect()и передачи:

Имя пользователя базы данных

Пароль базы данных для этого пользователя

Строка подключения «имя источника данных», см. раздел Строки подключения Oracle Net Services

Python-oracledb также поддерживает внешнюю аутентификацию , поэтому пароли не нужно указывать в приложении. Информация о других поддерживаемых методах аутентификации представлена ​​в разделе «Параметры аутентификации» .

4.1.1 Создание автономного подключения
Отдельные соединения создаются путем вызова oracledb.connect().

Простой пример автономного подключения:

import oracledb
import getpass

userpwd = getpass.getpass("Enter password: ")

connection = oracledb.connect(user="hr", password=userpwd,
                              dsn="dbhost.example.com/orclpdb")
В качестве альтернативы вы можете прочитать пароль из переменной среды:

userpwd = os.environ.get("PYTHON_PASSWORD")

connection = oracledb.connect(user="hr", password=userpwd,
                              dsn="localhost/orclpdb")
Этот oracledb.connect()метод позволяет передавать имя хоста базы данных и имя службы базы данных как отдельные параметры. Также можно передать порт прослушивателя базы данных:

import os

userpwd = os.environ.get("PYTHON_PASSWORD")

connection = oracledb.connect(user="hr", password=userpwd,
                              host="localhost", port=1521, service_name="orclpdb")
Можно передать одну комбинированную строку подключения, connect()но это может вызвать сложности, если пароль содержит символы «@» или «/»:

username="hr"
userpwd = os.environ.get("PYTHON_PASSWORD")
host = "localhost"
port = 1521
service_name = "orclpdb"

dsn = f'{username}/{userpwd}@{host}:{port}/{service_name}'
connection = oracledb.connect(dsn)
Если вы предпочитаете инкапсулировать значения, параметры можно передавать с помощью объекта ConnectParams :

params = oracledb.ConnectParams(host="my_host", port=my_port, service_name="my_service_name")
conn = oracledb.connect(user="my_user", password="my_password", params=params)
Некоторые значения, такие как имя хоста базы данных, можно указать в качестве connect() параметров, в составе dsnстроки подключения и в params объекте. Окончательная строка подключения формируется на основе любых параметров dsn, отдельных параметров и paramsзначений объекта. Приоритет заключается в том, что значения в dsnпараметре переопределяют значения, переданные как отдельные параметры, которые, в свою очередь, переопределяют значения, заданные в paramsобъекте.

4.1.1.1 Закрытие соединений
Подключения следует освобождать, когда они больше не нужны. Вы можете настроить автоматическую очистку подключений, когда ссылки на них выходят из области действия. Это позволит python-oracledb закрывать зависимые ресурсы в правильном порядке. Например, можно использовать блок менеджера контекста with Python :

with oracledb.connect(user="hr", password=userpwd, dsn="myhostname/orclpdb") as connection:
    with connection.cursor() as cursor:
        cursor.execute("insert into SomeTable values (:1)", ("Some string"))
        connection.commit()
Этот код гарантирует, что после завершения блока соединение будет закрыто, а ресурсы будут освобождены базой данных. Кроме того, любая попытка использовать переменную connectionвне блока завершится неудачей.

В качестве альтернативы вы можете явно закрыть соединение, вызвав Connection.close():

connection = oracledb.connect(user="hr", password=userpwd, dsn="localhost/orclpdb")

# do something with the connection
. . .

# close the connection
connection.close()
Если вы явно закрываете соединения, вам может потребоваться сначала закрыть другие ресурсы.

4.1.2 Распространенные ошибки подключения
Некоторые распространённые ошибки подключения, которые могут возникнуть в стандартном тонком режиме python-oracledb, подробно описаны ниже. См. также раздел Обработка ошибок в тонком и толстом режимах .

4.1.2.1. Используйте ключевые параметры
Если вы используете:

connection = oracledb.connect("hr", userpwd, "localhost/orclpdb")
то вы получите ошибку:

TypeError: connect() takes from 0 to 1 positional arguments but 3 were given
Метод oracledb.connect()требует использования ключевых параметров.

connection = oracledb.connect(user="hr", password=userpwd, dsn="localhost/orclpdb")
Исключение, передающее один аргумент, содержащий объединенные учетные данные и строку подключения. Поддерживается:

connection = oracledb.connect("hr/userpwd@localhost/orclpdb")
4.1.2.2. Используйте правильные учетные данные.
Если ваше имя пользователя или пароль неизвестны базе данных, к которой вы пытаетесь подключиться, то вы получите ошибку:

ORA-01017: invalid credential or not authorized; logon denied
Найдите правильное имя пользователя и пароль и попробуйте подключиться снова.

4.1.2.3. Используйте правильную строку подключения.
Если имя хоста, порта или имя службы неверны, то соединение завершится ошибкой:

DPY-6001: cannot connect to database. Service "doesnotexist" is not
registered with the listener at host "localhost" port 1521. (Similar to
ORA-12514)
Эта ошибка означает, что Python успешно установил соединение с компьютером (в данном случае «localhost» через порт по умолчанию 1521), на котором запущена база данных. Однако нужная вам служба базы данных («doesnotexist») там отсутствует.

Технически эта ошибка означает, что прослушиватель в данный момент не знает о сервисе. Поэтому эта ошибка может возникнуть и в случае перезапуска базы данных.

Эта ошибка похожа на ORA-12514ошибку, которую вы можете увидеть при подключении в режиме python-oracledb Thick или с некоторыми другими инструментами Oracle.

Решение — использовать корректное имя службы в строке подключения. Вы можете:

Проверьте и исправьте любые опечатки в названии используемой вами услуги.

Проверьте правильность имени хоста и порта.

Уточните у администратора базы данных (DBA) правильные значения.

Подождите несколько минут и повторите попытку на случай, если база данных перезапускается.

Проверьте информацию о подключении в вашей облачной консоли или облачном кошельке, если вы используете облачную базу данных.

Запустите lsnrctl status на машине базы данных, чтобы найти известные имена служб.

4.2. Строки подключения Oracle Net Services
Параметр имени источника данных dsnдля oracledb.connect(), oracledb.create_pool(), oracledb.connect_async(), и oracledb.create_pool_async(), — это строка подключения Oracle Database Oracle Net Services (обычно сокращенно «строка подключения»), которая определяет, к какой службе базы данных необходимо подключиться. Значение dsnможет быть одним из методов именования Oracle Database:

Строка Oracle Easy Connect

Дескриптор соединения

Сопоставление псевдонима TNS с дескриптором подключения, хранящимся в файле tnsnames.ora

URL -адрес LDAP

URL-адрес поставщика конфигурации

Строки подключения, используемые для JDBC и Oracle SQL Developer, необходимо изменить, чтобы их можно было использовать в качестве dsnзначения, см. Строки подключения JDBC и Oracle SQL Developer .

Дополнительные сведения о методах именования см. в Руководстве администратора Database Net Services .

Примечание

Для создания соединения в тонком режиме python-oracledb всегда требуется указать строку соединения или имя хоста базы данных и имя сервиса. В тонком режиме невозможно использовать соединения «по наследству» и не используются переменные среды Oracle ORACLE_SID, TWO_TASK, или LOCAL.

4.2.1 Синтаксис Easy Connect для строк подключения
Строка Easy Connect часто является самой простой строкой подключения для использования в параметре имени источника данных dsnфункций подключения, таких как oracledb.connect(), oracledb.create_pool(), oracledb.connect_async(), и oracledb.create_pool_async().

Использование строк Easy Connect означает, что внешний файл конфигурации tnsnames.ora не требуется.

Синтаксис Easy Connect в python-oracledb следующий:

[[protocol:]//]host1{,host12}[:port1]{,host2:port2}{;host1{,host12}[:port1]}[/[service_name][:server][/instance_name]][?parameter_name=value{&parameter_name=value}]
Более подробную информацию см. в Руководстве администратора Database Net Services и техническом описании Oracle Database Easy Connect Plus .

Например, чтобы подключиться к службе Oracle Database orclpdb, работающей на хосте dbhost.example.comс портом Oracle Database по умолчанию 1521, используйте:

connection = oracledb.connect(user="hr", password=userpwd,
                              dsn="dbhost.example.com/orclpdb")
Если база данных использует порт, отличный от порта по умолчанию, его необходимо указать:

connection = oracledb.connect(user="hr", password=userpwd,
                              dsn="dbhost.example.com:1984/orclpdb")
Синтаксис Easy Connect поддерживает имена служб Oracle Database. Его нельзя использовать со старыми системными идентификаторами (SID).

Настройки Oracle Net в строках Easy Connect

Синтаксис Easy Connect позволяет настраивать некоторые параметры конфигурации сети Oracle и базы данных . Это означает, что для распространённых сценариев подключения файл sqlnet.ora не требуется.

Например, чтобы установить время ожидания соединения и значение keep-alive:

connection = oracledb.connect(user="hr", password=userpwd,
             dsn="dbhost.example.com/orclpdb?transport_connect_timeout=10&expire_time=2")
Дополнительные сведения см. в разделах Oracle Net Connect Descriptor и Easy Connect Keywords . Любые параметры Easy Connect, неизвестные python-oracledb, игнорируются и не передаются в базу данных.

Настройки Python-oracledb в строках Easy Connect

Многие аргументы API метода подключения python-oracledb можно также передавать как параметры Easy Connect с префиксом «pyo». Например, чтобы задать размер кэша операторов, используемый соединениями:

connection = oracledb.connect(user="hr", password=userpwd,
                              dsn="dbhost.example.com/orclpdb?pyo.stmtcachesize=50")
Используемые атрибуты см. в разделе Параметры Python-oracledb, устанавливаемые в строках Easy Connect или Поставщики централизованной конфигурации .

4.2.2. Соединительные дескрипторы
Дескрипторы подключений можно встраивать непосредственно в приложения python-oracledb или ссылаться на них через псевдоним TNS .

Пример прямого использования:

dsn = """(DESCRIPTION=
             (FAILOVER=on)
             (ADDRESS_LIST=
               (ADDRESS=(PROTOCOL=tcp)(HOST=sales1-svr)(PORT=1521))
               (ADDRESS=(PROTOCOL=tcp)(HOST=sales2-svr)(PORT=1521)))
             (CONNECT_DATA=(SERVICE_NAME=sales.example.com)))"""

connection = oracledb.connect(user="hr", password=userpwd, dsn=dsn)
Функции oracledb.ConnectParams()и ConnectParams.get_connect_string()можно использовать для создания дескриптора соединения из отдельных компонентов. См. раздел Использование класса ConnectParams Builder . Например:

cp = oracledb.ConnectParams(host="dbhost.example.com", port=1521, service_name="orclpdb")
dsn = cp.get_connect_string()
print(dsn)
Это печатает:

(DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=dbhost.example.com)(PORT=1521))(CONNECT_DATA=(SERVICE_NAME=orclpdb)))
Синтаксис показан в Справочнике по службам баз данных Net .

Любые DESCRIPTIONпараметры CONNECT_DATAи SECURITYдескриптора полного соединения, не распознанные python-oracledb, передаются в базу данных без изменений.

4.2.3 Псевдонимы TNS для строк подключения
Дескрипторы подключения обычно хранятся в файле tnsnames.ora и связаны с псевдонимом TNS. Этот псевдоним можно использовать непосредственно для параметра имени источника данныхdsn, oracledb.connect(),oracledb.create_pool(), oracledb.connect_async()иoracledb.create_pool_async(). Например, если файл/opt/oracle/config/tnsnames.oraсодержит следующее:

ORCLPDB =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = dbhost.example.com)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = orclpdb)
    )
  )
Затем вы можете подключиться, передав псевдоним TNS «ORCLPDB» (без учета регистра) в качестве dsnзначения:

connection = oracledb.connect(user="hr", password=userpwd, dsn="orclpdb",
                              config_dir="/opt/oracle/config")
В режиме python-oracledb Thick каталог конфигурации также можно задать во время инициализации библиотеки:

oracledb.init_oracle_client(config_dir="/opt/oracle/config")
connection = oracledb.connect(user="hr", password=userpwd, dsn="orclpdb")
Дополнительные параметры того, как python-oracledb находит файлы tnsnames.ora , подробно описаны в разделе Использование дополнительных файлов конфигурации Oracle .

Псевдонимы TNS также могут быть разрешены с помощью LDAP .

Дополнительную информацию об именах сетевых служб см. в Справочнике по сетевым службам баз данных .

4.2.4 Строки подключения URL-адресов LDAP
Строка подключения python-oracledb может быть URL-адресом LDAP, например:

ldapurl = "ldaps://ldapserver.example.com/cn=orcl,cn=OracleContext,dc=example,dc=com"
connection = oracledb.connect(user="scott", password=pw, dsn=ldapurl)
Этот синтаксис устраняет необходимость во внешних sqlnet.oraфайлах LDAP и конфигурации. См. технический документ Oracle Client 23ai LDAP URL Syntax .

В тонком режиме python-oracledb для обработки этого протокола требуется дополнительная функция-перехватчик протокола соединения (см. раздел «Именование каталогов LDAP» ). В толстом режиме python-oracledb также требуется функция-перехватчик протокола соединения, если oracledb.defaults.thick_mode_dsn_passthroughзначение равно False .

Чтобы использовать URL-адреса LDAP в приложениях python-oracledb в режиме Thick, когда oracledb.defaults.thick_mode_dsn_passthroughустановлено значение True , клиентские библиотеки Oracle должны быть версии 23.4 или более поздней.

4.2.5. Строки подключения URL-адреса поставщика централизованной конфигурации
Строка подключения к URL-адресу поставщика централизованной конфигурации позволяет централизованно хранить информацию о конфигурации python-oracledb в хранилище объектов OCI, в конфигурации приложений Azure или в локальном файле. При наличии URL-адреса поставщика python-oracledb получит доступ к информации, хранящейся в поставщике конфигурации, и будет использовать её для подключения к базе данных Oracle.

Дескриптор подключения к базе данных и все учётные данные базы данных, хранящиеся в поставщике конфигурации, будут использоваться любым языковым драйвером, который обращается к этой конфигурации. Могут существовать и другие разделы, специфичные для драйвера. Python-oracledb будет использовать параметры из раздела с префиксом «pyo» и игнорировать остальные разделы.

Например, чтобы использовать конфигурацию соединения, сохраненную в локальном файле /opt/oracle/my-config.json:

{
  "connect_descriptor": "localhost/orclpdb",
  "pyo": {
    "min": 5,
    "max": 10,
    "increment": 2
    "stmtcachesize": 4
  }
}
Вы можете использовать это для создания пула подключений, указав dsn параметр строки подключения следующим образом:

pool = oracledb.create_pool(user="hr", password=userpwd,
                            dsn="config-file:///opt/oracle/my-config.json")
Пул будет создан с использованием настроек пула из конфигурации.

URL-адрес поставщика централизованной конфигурации должен начинаться с «config-<configuration-provider>://», где значение configuration-provider может быть установлено на ociobject , azure или file в зависимости от расположения информации о конфигурации.

Дополнительную информацию см. в разделе Поставщики централизованной конфигурации , в частности, касательно использования толстого режима python-oracledb.

Допустимые ключи для объекта «pyo» показаны в параметрах Python-oracledb, устанавливаемых в строках Easy Connect или поставщиках централизованной конфигурации .

4.2.6 Строки подключения JDBC и Oracle SQL Developer
Синтаксис строки подключения python-oracledb отличается от синтаксиса Java JDBC и стандартного синтаксиса Oracle SQL Developer. Если эти строки подключения JDBC ссылаются на имя службы, например:

jdbc:oracle:thin:@hostname:port/service_name
Например:

jdbc:oracle:thin:@dbhost.example.com:1521/orclpdb
затем используйте синтаксис Oracle Easy Connect в python-oracledb:

connection = oracledb.connect(user="hr", password=userpwd,
                              dsn="dbhost.example.com:1521/orclpdb")
Возможно, вам придется удалить специфичные для JDBC параметры из строки подключения и использовать альтернативы python-oracledb.

Если строка подключения JDBC использует устаревший «системный идентификатор» Oracle Database SID, а у базы данных нет имени службы:

jdbc:oracle:thin:@hostname:port:sid
Например:

jdbc:oracle:thin:@dbhost.example.com:1521:orcl
затем подключитесь, используя sidпараметр:

connection = oracledb.connect(user="hr", password=userpwd,
                              host="dbhost.example.com", port=1521, sid="orcl")
В качестве альтернативы создайте tnsnames.oraзапись (см. Дополнительные файлы конфигурации Oracle Net ), например:

finance =
 (DESCRIPTION =
   (ADDRESS = (PROTOCOL = TCP)(HOST = dbhost.example.com)(PORT = 1521))
   (CONNECT_DATA =
     (SID = ORCL)
   )
 )
На это можно сослаться в python-oracledb:

connection = oracledb.connect(user="hr", password=userpwd, dsn="finance")
4.2.7. Дескриптор Oracle Net Connect и ключевые слова Easy Connect
Синтаксис Easy Connect описан в разделе Синтаксис Easy Connect для строк подключения .

Ключевые слова дескриптора подключения приведены в справочнике служб баз данных Net Services .

Примечания по конкретным ключевым словам

Значения POOL_CONNECTION_CLASS«или» POOL_PURITYбудут работать только при подключении к Oracle Database 21c или более поздней версии. Обратите внимание, что если POOL_PURITY=SELFиспользуется в строке подключения, то приложения python-oracledb в толстом режиме будут игнорировать действие по удалению сеанса при попытке удалить неиспользуемые соединения из пула в некоторых редких случаях ошибок. Рекомендуется избегать использования POOL_PURITY=SELFв строке подключения с python-oracledb в толстом режиме. Вместо этого в коде приложений python-oracledb в толстом режиме явно указывайте чистоту и класс соединения в качестве атрибутов.

Параметр ENABLE=BROKENдескриптора подключения не поддерживается в тонком режиме python-oracledb. EXPIRE_TIMEВместо него используйте .

Если имя указано в строке подключения, python-oracledb будет рассматривать его как имя сетевой службы, а не как минимальную строку Easy Connect для имени хоста. Поиск данной строки подключения будет осуществляться в файле tnsnames.ora . Если для вас важна поддержка простого имени в качестве имени хоста в python-oracledb, вы можете изменить строку подключения, включив в неё протокол, например tcp://hostname, , или номер порта, например hostname:1521, .

В режиме Thick python-oracledb, если oracledb.defaults.thick_mode_dsn_passthroughустановлено значение False , любые DESCRIPTIONпараметры CONNECT_DATAдескриптора SECURITYполного соединения, нераспознанные python-oracledb, передаются в базу данных без изменений. Любые параметры Easy Connect, неизвестные python-oracledb, отбрасываются и не передаются в базу данных.

4.2.8 Параметры Python-oracledb, устанавливаемые в строках Easy Connect или поставщиках централизованной конфигурации
Некоторые параметры подключения и создания пула python-oracledb можно задать в строках Easy Connect или через централизованный поставщик конфигурации . Это альтернатива передаче явных аргументов в oracledb.connect(), oracledb.create_pool(), oracledb.connect_async(), или oracledb.create_pool_async(). Это позволяет изменять поведение приложения без необходимости обновления его кода.

Параметры представлены в таблице ниже . Параметры имеют префикс «pyo.» или находятся под ключом «pyo». Каждый из этих параметров, определенный в строке Easy Connect или через поставщика централизованной конфигурации, имеет приоритет над значением, переданным как эквивалентный параметр API python-oracledb.

Параметры, применяемые к созданию пула, будут игнорироваться при использовании в контексте отдельных подключений . Параметры с неизвестными именами будут игнорироваться в обоих случаях.

Параметры Python-oracledb в строках Easy Connect

Имена параметров Easy Connect аналогичны именам аргументов метода python-oracledb, но имеют префикс «pyo». Например:

cs = "host.example.com:1522/orclpdb?pyo.stmtcachesize=30&pyo.mode=SYSDBA"
connection = oracledb.connect(user="hr", password=userpwd, dsn=cs)
то же самое, что и:

cs = "host.example.com:1522/orclpdb"
connection = oracledb.connect(user="hr", password=userpwd, dsn=cs,
                   stmtcachesize=30, mode=oracledb.AuthMode.SYSDBA)
Если параметр указан несколько раз в строке Easy Connect, используется последнее значение этого параметра. Например, в строке «localhost/orclpdb?pyo.sdu=10&pyo.sdu=20» значение SDU равно 20.

Обратите внимание, что некоторые параметры Oracle Net также могут иметь префикс «pyo».

Параметры с префиксом «pyo.» можно использовать только в строках Easy Connect, но не в дескрипторах Connect .

Параметры Python-oracledb в поставщиках конфигурации

При использовании поставщика централизованной конфигурации файлов или поставщика централизованной конфигурации хранилища объектов OCI настраиваемые атрибуты драйвера python-oracledb должны находиться в JSON-файле в разделе «pyo». Пример:

{
  "connect_descriptor": "localhost/orclpdb",
  "pyo": {
    "min": 5,
    "max": 10,
    "increment": 2
    "stmtcachesize": 4
  }
}
В Azure App Configuration значения задаются с помощью ключа, например «<prefix>/pyo/<key name>». Это похоже на то, как настройки Oracle Call Interface используют ключ «<prefix>/oci/<key name>», как показано в руководстве администратора Oracle Net Service .

Имена параметров

При использовании в строках Easy Connect имена параметров должны начинаться с префикса «pyo». При использовании в поставщике централизованной конфигурации имена параметров формируют имена ключей в родительском ключе «pyo» или с префиксом «pyo/». Имена нечувствительны к регистру.

Таблица 4.1 Параметры Python-oracledb, используемые в строках Easy Connect или поставщиках централизованной конфигурации
Имя базового параметра

Тип/Значение

Эквивалентное имя параметра соединения python-oracledb

Примечания

CCLASS

Нить

cclass

Нет соответствующих заметок
CONNECTION_ID_PREFIX

Нить

connection_id_prefix

Нет соответствующих заметок
DISABLE_OOB

Строка, представляющая логическое значение. Возможные значения: «on» или «off» , «true» или «false» , «yes» или «no» (без учета регистра).

disable_oob

Нет соответствующих заметок
DRIVER_NAME

Нить

driver_name

Нет соответствующих заметок
EDITION

Нить

edition

Нет соответствующих заметок
EVENTS

Строка, представляющая логическое значение. Возможные значения: «on» или «off» , «true» или «false» , «yes» или «no» (без учета регистра).

events

Нет соответствующих заметок
EXPIRE_TIME

Целое число

expire_time

Нет соответствующих заметок
EXTERNALAUTH

Строка, представляющая логическое значение. Возможные значения: «on» или «off» , «true» или «false» , «yes» или «no» (без учета регистра).

externalauth

Нет соответствующих заметок
EXTRA_AUTH_PARAMS

Словарь, содержащий параметры конфигурации, необходимые для аутентификации Oracle Database с использованием OCI или собственных подключаемых модулей аутентификации облака Azure .

extra_auth_params

Только для использования поставщиками централизованной конфигурации

GETMODE

Строка, значения могут быть одним из FORCEGET , NOWAIT , WAIT или TIMEDWAIT , сопоставляемых с режимами получения пула подключений .

getmode

Только создание пула

HOMOGENEOUS

Строка, представляющая логическое значение. Возможные значения: «on» или «off» , «true» или «false» , «yes» или «no» (без учета регистра).

homogeneous

Только создание пула

HTTPS_PROXY

Нить

https_proxy

Нет соответствующих заметок
HTTPS_PROXY_PORT

Целое число

https_proxy_port

Нет соответствующих заметок
INCREMENT

Целое число

increment

Только создание пула

MACHINE

Нить

machine

Нет соответствующих заметок
MAX

Целое число

max

Только создание пула

MAX_LIFETIME_SESSION

Целое число

max_lifetime_session

Только создание пула

MAX_SESSIONS_PER_SHARD

Целое число

max_sessions_per_shard

Только создание пула

MIN

Целое число

min

Только создание пула

MODE

Строка, значения могут быть DEFAULT , PRELIM , SYSASM , SYSBKP , SYSDBA , SYSDGD , SYSKMT , SYSOPER или SYSRAC , соответствующие режимам авторизации подключения .

mode

Нет соответствующих заметок
OSUSER

Нить

osuser

Нет соответствующих заметок
PING_INTERVAL

Целое число

ping_interval

Только создание пула

PING_TIMEOUT

Целое число

ping_timeout

Только создание пула

POOL_BOUNDARY

Нить

pool_boundary

Нет соответствующих заметок
PROGRAM

Нить

program

Нет соответствующих заметок
PURITY

Строка, значения могут быть DEFAULT , NEW или SELF , сопоставленные с константами чистоты пула подключений .

purity

Нет соответствующих заметок
RETRY_COUNT

Целое число

retry_count

Нет соответствующих заметок
RETRY_DELAY

Целое число

retry_delay

Нет соответствующих заметок
SDU

Целое число

sdu

Нет соответствующих заметок
SODA_METADATA_CACHE

Строка, представляющая логическое значение. Возможные значения: «on» или «off» , «true» или «false» , «yes» или «no» (без учета регистра).

soda_metadata_cache

Только создание пула

SSL_SERVER_CERT_DN

Нить

ssl_server_cert_dn

Нет соответствующих заметок
SSL_SERVER_DN_MATCH

Строка, представляющая логическое значение. Возможные значения: «on» или «off» , «true» или «false» , «yes» или «no» (без учета регистра).

ssl_server_dn_match

Нет соответствующих заметок
STMTCACHESIZE

Целое число

stmtcachesize

Нет соответствующих заметок
TCP_CONNECT_TIMEOUT

Целое число

tcp_connect_timeout

Нет соответствующих заметок
TERMINAL

Нить

terminal

Нет соответствующих заметок
TIMEOUT

Целое число

timeout

Только создание пула

USE_TCP_FAST_OPEN

Строка, представляющая логическое значение. Возможные значения: «on» или «off» , «true» или «false» , «yes» или «no» (без учета регистра).

use_tcp_fast_open

Нет соответствующих заметок
USE_SNI

Строка, представляющая логическое значение. Возможные значения: «on» или «off» , «true» или «false» , «yes» или «no» (без учета регистра).

use_sni

Нет соответствующих заметок
WAIT_TIMEOUT

Целое число

wait_timeout

Только создание пула

WALLET_LOCATION

Нить

wallet_location

Не рекомендуется использовать в поставщиках конфигурации, поскольку имя пути может быть недействительным на каком-либо конкретном хосте приложения.

4.3. Аутентификация в базе данных Oracle
При подключении к Oracle Database аутентификация играет ключевую роль в установлении авторизованного соединения. Python-oracledb поддерживает различные методы аутентификации Oracle Database, перечисленные ниже:

Аутентификация базы данных

Прокси-аутентификация

Внешняя аутентификация

Аутентификация на основе токенов

Аутентификация субъекта экземпляра

Библиотеки клиента Oracle, используемые режимом python-oracledb Thick, могут поддерживать дополнительные методы аутентификации, которые настраиваются независимо от драйвера.

4.4. Поставщики централизованной конфигурации
Поставщики централизованной конфигурации позволяют централизованно хранить и управлять учётными данными для подключения к базе данных и информацией о конфигурации приложения. Поставщики позволяют хранить информацию о конфигурации отдельно от кода приложения. Сохраняемые значения включают строку подключения к базе данных, учётные данные базы данных, время кэширования и специфичные для python-oracledb атрибуты, такие как настройки пула соединений. Python-oracledb может использовать централизованно хранимую информацию для подключения к Oracle Database с помощью oracledb.connect(), oracledb.create_pool(), oracledb.connect_async()и oracledb.create_pool_async().

Python-oracledb поддерживает следующие поставщики конфигурации:

Поставщик централизованной конфигурации файлов

Поставщик централизованной конфигурации хранилища объектов Oracle Cloud Infrastructure (OCI)

Поставщик централизованной конфигурации приложений Microsoft Azure

Чтобы использовать функциональность поставщика централизованной конфигурации в режиме python-oracledb Thick, установите oracledb.defaults.thick_mode_dsn_passthroughзначение False . В качестве альтернативы можно использовать ConnectParams.parse_connect_string(), см. раздел Использование класса ConnectParams Builder .

Примечание: В режиме Thick, если oracledb.defaults.thick_mode_dsn_passthroughустановлено значение True , клиентские библиотеки Oracle обращаются к поставщику конфигурации при вызове методов подключения или создания пула python-oracledb. Любой раздел параметров python-oracledb будет проигнорирован. Любой раздел параметров клиентского интерфейса Oracle следует удалить из конфигурации, поскольку его значения могут отличаться от предполагаемых python-oracledb, что приведет к неопределенному поведению.

Приоритет атрибутов

userНе рекомендуется определять атрибуты в нескольких местах. Однако, если значения и определены как в passwordприложении, так и в поставщике конфигурации, то значения, заданные в приложении, будут иметь более высокий приоритет. Если параметру externalauthприсвоено значение True , то значения userи password, указанные в поставщике конфигурации, игнорируются.

Если другие атрибуты соединения python-oracledb определены как в приложении, так и в поставщике конфигурации, то значения, определенные в поставщике конфигурации, будут иметь более высокий приоритет.

Если вы используете толстый режим и определили атрибуты python-oracledb в oraaccess.xmlфайле (см. раздел Необязательный файл конфигурации клиента Oracle ), поставщик конфигурации и приложение, то значения, определенные в поставщике конфигурации, будут иметь более высокий приоритет, за которыми следуют oraaccess.xmlнастройки файла, а затем настройки приложения.

4.4.1 Использование поставщика централизованной конфигурации файлов
Поставщик централизованной конфигурации файлов обеспечивает хранение и управление информацией о соединениях с базой данных Oracle с использованием локальных файлов.

Чтобы использовать поставщик централизованной конфигурации файлов, необходимо:

Сохраните информацию о подключении в JSON-файле в локальной файловой системе.

Укажите путь к файлу в параметрах dsnподключения и методах создания пула.

Синтаксис файла JSON поставщика централизованной конфигурации файла

Файл конфигурации должен содержать как минимум один connect_descriptorключ, задающий строку подключения к базе данных. При желании вы можете сохранить имя пользователя базы данных, пароль, время кэширования и настройки python-oracledb . В файле могут храниться следующие ключи:

Таблица 4.2 Ключи JSON для поставщика конфигурации файлов
Ключ

Описание

Обязательно или необязательно

user

Имя пользователя базы данных.

Необязательный

password

Пароль пользователя базы данных как словарь, содержащий ключ «тип» и ключи, специфичные для типа пароля.



Предупреждение


Хранение паролей в файле конфигурации следует использовать только в средах разработки или тестирования.



Необязательный

connect_descriptor

Строка подключения к базе данных .

Необходимый

config_time_to_live

Количество секунд, в течение которых кэшируется конфигурация. Значение по умолчанию — 86 400 секунд (24 часа).

Необязательный

config_time_to_live_grace_period

Количество секунд, в течение которых можно использовать устаревшую конфигурацию, если невозможно получить новую. Значение по умолчанию — 1800 секунд (30 минут).

Необязательный

pyo

См. раздел Параметры Python-oracledb, устанавливаемые в строках Easy Connect или поставщиках централизованной конфигурации .

Необязательный

Дополнительные сведения об универсальных подобъектах поставщика, которые можно использовать в файлах JSON, см . в руководстве администратора Oracle Net Service .

Можно определить несколько конфигураций, указав вышеуказанные ключи в качестве выбираемых пользователем ключей верхнего уровня, см. пример ниже.

Синтаксис DSN поставщика централизованной конфигурации файлов

Чтобы использовать поставщик файлов, укажите dsnпараметр oracledb.connect(), oracledb.create_pool(), oracledb.connect_async(), или , oracledb.create_pool_async()используя следующий формат:

config-file://<file-path-and-name>[?key=<key_name>]
Элементы параметра dsnподробно описаны в таблице ниже.

Таблица 4.3 Параметры строки подключения для поставщика конфигурации файла
Параметр

Описание

config-file

Указывает, что поставщик централизованной конфигурации — это файл в вашей локальной системе.

<имя-файла>

Путь к файлу и имя JSON-файла, содержащего информацию о конфигурации. Для относительных путей python-oracledb будет использовать config_dirпараметр (или
 oracledb.defaults.config_dirзначение) создания подключения или пула для создания абсолютного пути.

key

Имя ключа подключения, используемое для идентификации конкретной конфигурации. Если этот параметр указан, предполагается, что файл содержит несколько конфигураций, индексированных по значению ключа. Если параметр не указан, предполагается, что файл содержит одну конфигурацию. См. пример ниже.

Примеры поставщика конфигурации файлов

Пример синтаксиса файла поставщика конфигурации файлов:

{
    "user": "scott",
    "password": {
        "type": "base64",
        "value": "dGlnZXI="
    },
    "connect_descriptor": "dbhost.example.com:1522/orclpdb",
    "pyo": {
        "stmtcachesize": 30,
        "min": 2,
        "max": 10
    }
}
Пароль кодируется в формате base64. Другие примеры паролей см. в разделе «Использование поставщика централизованной конфигурации объектного хранилища OCI» . Пароли в виде открытого текста не поддерживаются.

Обратите внимание, что python-oracledb кэширует конфигурации по умолчанию, см. раздел Информация о конфигурации кэширования .

Если у вас есть этот файл конфигурации в /opt/oracle/my-config1.json, вы можете использовать его следующим образом:

connection = oracledb.connect(dsn="config-file:///opt/oracle/my-config1.json")
Можно определить несколько конфигураций, указав выбранные пользователем ключи верхнего уровня:

{
    "production": {
        "connect_descriptor": "localhost/orclpdb"
    },
    "testing": {
        "connect_descriptor": "localhost/orclpdb",
        "user": "scott",
        "password": {
            "type": "base64",
            "value": "dGlnZXI="
        }
    }
}
Если у вас есть этот файл конфигурации в /opt/oracle/my-config2.json, вы можете использовать его следующим образом:

connection = oracledb.connect(user="hr", password=userpwd,
             dsn="config-file:///opt/oracle/my-config2.json?key=production")
4.4.2 Использование поставщика централизованной конфигурации хранилища объектов OCI
Поставщик конфигурации хранилища объектов Oracle Cloud Infrastructure (OCI) обеспечивает хранение и управление информацией о подключении к базе данных Oracle в формате JSON в хранилище объектов OCI .

Чтобы использовать поставщик централизованной конфигурации хранилища объектов OCI, необходимо:

Загрузите JSON-файл с информацией о подключении в контейнер OCI Object Storage. Инструкции см. в разделе «Загрузка объекта Object Storage в контейнер» и в руководстве администратора Oracle Net Service . Сведения о конфигурации, которую можно добавить, см. в разделе «Параметры поставщика централизованной конфигурации OCI Object Storage» .

Установите модуль Python OCI , см. раздел Установка модулей для поставщика централизованной конфигурации хранилища объектов OCI .

Импортируйте плагин oracledb.plugins.oci_config_provider в свое приложение.

Используйте URL-адрес строки подключения к хранилищу объектов OCI вdsnпараметрах методов подключения и создания пула.

Синтаксис файла JSON поставщика централизованной конфигурации хранилища объектов OCI

Сохранённый JSON-файл конфигурации должен содержать connect_descriptorключ. При желании можно указать имя пользователя базы данных, пароль, время кэширования и атрибуты python-oracledb. Пароль базы данных также можно безопасно хранить в OCI Vault или Azure Key Vault . Ключи, которые могут содержаться в JSON-файле, перечислены ниже.

Таблица 4.4 Ключи JSON для поставщика конфигурации хранилища объектов OCI
Ключ

Описание

Обязательно или необязательно

user

Имя пользователя базы данных.

Необязательный

password

Пароль пользователя базы данных как словарь, содержащий ключ «тип» и ключи, специфичные для типа пароля.

Необязательный

connect_descriptor

Строка подключения к базе данных .

Необходимый

config_time_to_live

Количество секунд, в течение которых кэшируется конфигурация. Значение по умолчанию — 86 400 секунд (24 часа).

Необязательный

config_time_to_live_grace_period

Количество секунд, в течение которых можно использовать устаревшую конфигурацию, если невозможно получить новую. Значение по умолчанию — 1800 секунд (30 минут).

Необязательный

pyo

См. раздел Параметры Python-oracledb, устанавливаемые в строках Easy Connect или поставщиках централизованной конфигурации .

Необязательный

Синтаксис DSN поставщика централизованной конфигурации хранилища объектов OCI

Параметр dsnдля вызовов oracledb.connect(), oracledb.create_pool(), oracledb.connect_async(), или oracledb.create_pool_async()должен использовать URL-адрес строки подключения в формате:

config-ociobject:<objectstorage-name>/n/{namespaceName}/b/{bucketName}/o/
<objectName>[/c/<networkServiceName>][?<option1>=<value1>&<option2>=<value2>...]
Элементы строки подключения подробно описаны в таблице ниже.

Таблица 4.5 Параметры строки подключения для хранилища объектов OCI
Параметр

Описание

Обязательно или необязательно

config-ociobject

Указывает, что поставщиком конфигурации является OCI Object Storage.

Необходимый

<имя_хранилища_объектов>

URL-адрес конечной точки хранилища объектов OCI.

Необходимый

<имя_пространства_имен>

Пространство имен OCI Object Storage, в котором хранится JSON-файл.

Необходимый

<имя_ведра>

Имя контейнера хранилища объектов OCI, в котором хранится файл JSON.

Необходимый

<ИмяОбъекта>

Имя JSON-файла.

Необходимый

<имя_сетевой_службы>

Имя сетевой службы или псевдоним, если файл JSON содержит одно или несколько имен сетевых служб.

Необязательный

<опция>=<значение>

Метод аутентификации и соответствующие ему параметры для доступа к поставщику конфигурации хранилища объектов OCI. Вы можете указать один из следующих методов аутентификации: аутентификация на основе API-ключа, аутентификация субъекта экземпляра и аутентификация субъекта ресурса. Подробнее см. в разделе «Методы аутентификации поставщика конфигурации хранилища объектов OCI» .

Необязательный

Примеры поставщика централизованной конфигурации хранилища объектов OCI

Пример синтаксиса JSON-файла поставщика конфигурации централизованного хранилища объектов OCI:

{
    "user": "scott",
    "password": {
        "type": "ocivault",
        "value": "oci.vaultsecret.my-secret-id"
        "authentication": {
            "method": "OCI_INSTANCE_PRINCIPAL"
        }
    },
    "connect_descriptor": "dbhost.example.com:1522/orclpdb",
    "pyo": {
        "stmtcachesize": 30,
        "min": 2,
        "max": 10
    }
}
Пароли можно хранить в Azure Key Vault. Для этого необходимо импортировать плагин oracledb.plugins.azure_config_provider python-oracledb в приложение и определить учётные данные Azure Key Vault в passwordключе. При этом необходимо указать azure_client_idи azure_tenant_id. Также следует указать azure_client_secretили azure_client_certificate_path. Например:

"password": {
    "type": "azurevault",
    "value": "<Azure Key Vault URI>",
    "authentication": {
        "azure_tenant_id": "<tenant_id>",
        "azure_client_id": "<client_id>",
        "azure_client_secret": "<secret value>"
    }
}
Или:

"password": {
    "type": "azurevault",
    "value": "<Azure Key Vault URI>",
    "authentication": {
        "azure_tenant_id": "<tenant_id>",
        "azure_client_id": "<client_id>",
        "azure_client_certificate_path": "<azure_client_certificate_path>"
    }
}
Обратите внимание, что python-oracledb кэширует конфигурации по умолчанию, см. раздел Информация о конфигурации кэширования .

Пример строки подключения для поставщика конфигурации OCI Object Centralized Storage:

configociurl = "config-ociobject://abc.oraclecloud.com/n/abcnamespace/b/abcbucket/o/abcobject?authentication=oci_default&oci_tenancy=abc123&oci_user=ociuser1&oci_fingerprint=ab:14:ba:13&oci_key_file=ociabc/ocikeyabc.pem"
Чтобы создать автономное соединение, можно использовать следующее:

import oracledb.plugins.oci_config_provider

configociurl = "config-ociobject://abc.oraclecloud.com/n/abcnamespace/b/abcbucket/o/abcobject?authentication=oci_default&oci_tenancy=abc123&oci_user=ociuser1&oci_fingerprint=ab:14:ba:13&oci_key_file=ociabc/ocikeyabc.pem"

connection = oracledb.connect(dsn=configociurl)
Конфигурацию также можно использовать для создания пула соединений , например:

pool = oracledb.create_pool(dsn=configociurl)
4.4.3 Использование поставщика централизованной конфигурации приложений Azure
Azure App Configuration — это облачный сервис, предоставляемый Microsoft Azure. Он может использоваться для хранения и управления информацией о подключениях к базе данных Oracle в виде пар «ключ-значение».

Чтобы использовать python-oracledb с конфигурацией приложений Azure, необходимо:

Сохраните информацию о конфигурации в поставщике конфигурации приложений Azure. См. раздел Параметры поставщика централизованной конфигурации приложений Azure .

Установите модули приложения Azure, см. раздел Установка модулей для поставщика централизованной конфигурации приложения Azure .

Импортируйте плагин oracledb.plugins.azure_config_provider в свое приложение.

Используйте URL-адрес строки подключения конфигурации приложений Azure вdsnпараметрах методов подключения и создания пула.

Параметры поставщика централизованной конфигурации приложений Azure

Пары «ключ-значение» для сохранённой информации о подключении можно добавить на странице обозревателя конфигурации приложения Azure. Дополнительные сведения см. в статье Создание пары «ключ-значение» в конфигурации приложения Azure . Кроме того, их можно задать с помощью вызовов REST . См. также руководство администратора Oracle Net Service .

Вы можете организовать пары «ключ-значение» под префиксом, соответствующим потребностям вашего приложения. Например, если у вас есть два приложения, «Продажи» и «Кадры», вы можете хранить соответствующую информацию о конфигурации под префиксами «sales» и « hr» .

Пары «ключ-значение» должны содержать ключ connect_descriptor, задающий строку подключения к базе данных. Это можно задать с помощью префикса «<prefix>/connect_descriptor», например, sales/connect_descriptor .

Имя пользователя базы данных можно дополнительно сохранить с помощью ключа, например, «<prefix>/user», а пароль — с помощью «<prefix>/password». Например, sales/user и sales/password . Пароль базы данных также можно безопасно хранить с помощью Azure Key Vault . Время кэширования можно также сохранить с помощью «<prefix>/config_time_to_live». Например, sales/60000 . См. раздел Информация о конфигурации кэширования .

Дополнительные параметры python-oracledb можно задать с помощью ключа, например, «<prefix>/pyo/<key name>», например, sales/pyo/min . Это аналогично тому, как параметры Oracle Call Interface используют ключи типа «<prefix>/oci/<key name>», как показано в руководстве Oracle Net Service Administrator's Guide .

Ниже перечислены ключи, которые можно добавить в конфигурацию приложений Azure:

Таблица 4.6 Ключи для конфигурации приложений Azure
Ключ

Описание

Обязательно или необязательно

user

Имя пользователя базы данных.

Необязательный

password

Пароль пользователя базы данных в виде словаря, содержащего ключ «type» и ключи, специфичные для типа пароля. При использовании Azure Key Vault это может быть URI хранилища, содержащего секретный ключ, указанный с помощью ключа «uri».

Необязательный

connect_descriptor

Строка подключения к базе данных .

Необходимый

config_time_to_live

Количество секунд, в течение которых кэшируется конфигурация. Значение по умолчанию — 86 400 секунд (24 часа).

Необязательный

config_time_to_live_grace_period

Количество секунд, в течение которых можно использовать устаревшую конфигурацию, если невозможно получить новую. Значение по умолчанию — 1800 секунд (30 минут).

Необязательный

pyo

См. раздел Параметры Python-oracledb, устанавливаемые в строках Easy Connect или поставщиках централизованной конфигурации .

Необязательный

Синтаксис DSN поставщика централизованной конфигурации приложений Azure

Для доступа к информации, хранящейся в Конфигурации приложений Azure, необходимо указать URL-адрес строки подключения в определённом формате в dsn параметре oracledb.connect(), oracledb.create_pool(), oracledb.connect_async(), или . oracledb.create_pool_async()Синтаксис следующий:

config-azure://<appconfigname>[?key=<prefix>&label=<value>&<option1>=<value1>&<option2>=<value2>...]
Элементы строки подключения подробно описаны в таблице ниже.

Таблица 4.7 Параметры строки подключения для поставщика централизованной конфигурации приложений Azure
Параметр

Описание

Обязательно или необязательно

config-azure

Указывает, что поставщиком конфигурации является Azure App Configuration.

Необходимый

<имя_конфигурации_приложения>

URL-адрес конечной точки конфигурации приложения Azure. Суффикс «.azconfig.io» в имени необязателен.

Необходимый

ключ=<префикс>

Ключевой префикс для идентификации соединения. Вы можете организовать информацию о конфигурации с помощью префикса в соответствии с требованиями приложения.

Необходимый

метка=<значение>

Имя метки конфигурации приложения Azure.

Необязательный

<опция>=<значение>

Метод аутентификации и соответствующие ему параметры для доступа к поставщику конфигурации приложений Azure. Вы можете указать один из следующих методов аутентификации: «Учётные данные Azure по умолчанию», «Субъект-служба с секретом клиента», «Субъект-служба с сертификатом клиента» и «Управляемое удостоверение». Дополнительные сведения об этих методах аутентификации и соответствующих параметрах см. в разделе «Методы аутентификации поставщика конфигурации приложений Azure» .

Необязательный

Примеры централизованной конфигурации приложений Azure

В следующей таблице представлен пример конфигурации, заданной с помощью страницы обозревателя конфигураций поставщика конфигурации приложений Azure. В примере используется префикс test/.

Пример ключа конфигурации приложения Azure

Пример значения

тест/дескриптор_подключения

dbhost.example.com:1522/orclpdb

тест/пользователь

scott

тест/пароль

{"uri":"https://mykeyvault.vault.azure.net/secrets/passwordsales"}

тест/пио/макс

20

Обратите внимание, что python-oracledb кэширует конфигурации по умолчанию, см. раздел Информация о конфигурации кэширования .

Пример строки подключения для поставщика конфигурации приложений Azure:

configazureurl = "config-azure://aznetnamingappconfig.azconfig.io/?key=test/&azure_client_id=123-456&azure_client_secret=MYSECRET&azure_tenant_id=789-123"
Пример использования автономного соединения :

import oracledb.plugins.azure_config_provider

configazureurl = "config-azure://aznetnamingappconfig.azconfig.io/?key=test/&azure_client_id=123-456&azure_client_secret=MYSECRET&azure_tenant_id=789-123"

oracledb.connect(dsn=configazureurl)
Конфигурацию также можно использовать для создания пула соединений , например:

oracledb.create_pool(dsn=configazureurl)
4.4.4 Кэширование информации о конфигурации
Python-oracledb кэширует конфигурации, полученные от поставщиков централизованной конфигурации, для снижения накладных расходов на доступ.

Вы можете использовать config_time_to_liveключ конфигурации, чтобы указать время в секундах, в течение которого python-oracledb будет хранить информацию в кэше. Значение по умолчанию — 86 400 секунд (24 часа).

При config_time_to_liveдостижении этого значения конфигурация считается «мягко устаревшей», и последующие подключения python-oracledb будут пытаться получить её заново у поставщика конфигурации. Если её не удаётся получить, python-oracledb продолжит использовать предыдущую конфигурацию в течение config_time_to_live_grace_period1800 секунд (по умолчанию 30 минут). По истечении этого периода кэшированная конфигурация полностью устаревает. Последующие попытки подключения будут пытаться получить конфигурацию у поставщика, но завершится неудачей, если новую конфигурацию получить не удастся.

Пример изменения времени кэширования до 12 часов с дополнительным льготным периодом в 10 минут для поставщиков централизованной конфигурации файлового или объектного хранилища OCI:

{
    "connect_descriptor": "dbhost.example.com:1522/orclpdb",
    "config_time_to_live": 43200,
    "config_time_to_live_grace_period": 600,
    "pyo": {
        "stmtcachesize": 30,
        "min": 2,
        "max": 10
    }
}
4.5 Использование класса-конструктора ConnectParams
Класс ConnectParams позволяет определить параметры подключения в одном месте. Функция oracledb.ConnectParams()возвращает объект ConnectParams . Этот объект можно передать в метод oracledb.connect()или oracledb.connect_async(). Например:

cp = oracledb.ConnectParams(user="hr", password=userpwd,
                            host="dbhost", port=1521, service_name="orclpdb")
connection = oracledb.connect(params=cp)
Информацию о пулах соединений см. в разделе Использование класса PoolParams Builder .

Использование класса ConnectParams необязательно, поскольку те же параметры можно передать непосредственно в connect(). Например, код выше эквивалентен следующему:

connection = oracledb.connect(user="hr", password=userpwd,
                              host="dbhost", port=1521, service_name="orclpdb")
Если вы хотите хранить учетные данные отдельно, вы можете использовать ConnectParams только для инкапсуляции компонентов строки подключения:

cp = oracledb.ConnectParams(host="dbhost", port=1521, service_name="orclpdb")
connection = oracledb.connect(user="hr", password=userpwd, params=cp)
ConnectParams.get_connect_string()Для получения строки подключения из объекта ConnectParams можно использовать :

cp = oracledb.ConnectParams(host="dbhost", port="my_port", service_name="my_service_name")
dsn = cp.get_connect_string()
connection = oracledb.connect(user="hr", password=userpwd, dsn=dsn)
Некоторые значения, такие как имя хоста базы данных, можно указать в качестве connect() параметров, в составе dsnстроки подключения и в params объекте. Окончательная строка подключения формируется на основе любых параметров dsn, отдельных параметров и paramsзначений объекта. Приоритет заключается в том, что значения в dsnпараметре переопределяют значения, переданные как отдельные параметры, которые, в свою очередь, переопределяют значения, заданные в paramsобъекте.

Чтобы проанализировать строку подключения и сохранить её компоненты как атрибуты экземпляра ConnectParams, используйте ConnectParams.parse_connect_string(). Например:

dsn = "host.example.com:1522/orclpdb?transport_connect_timeout=15&pyo.stmtcachesize=30"
cp = oracledb.ConnectParams()
cp.parse_connect_string(dsn)

connection = oracledb.connect(user="hr", password=userpwd, params=cp)
Большинство значений параметров oracledb.ConnectParams()можно получить как атрибуты. Например, чтобы получить сохранённое имя хоста:

print(cp.host)
Такие атрибуты, как пароль, получить невозможно.

Вы можете задать отдельные атрибуты по умолчанию, используя ConnectParams.set():

cp = oracledb.ConnectParams(host="localhost", port=1521, service_name="orclpdb")

# set a new port
cp.set(port=1522)

# change both the port and service name
cp.set(port=1523, service_name="orclpdb")
Примечание ConnectParams.set()не имеет никакого эффекта после ConnectParams.parse_connect_string()вызова.

Этот метод ConnectParams.parse_dsn_with_credentials()можно использовать для извлечения имени пользователя, пароля и строки подключения из DSN:

cp = oracledb.ConnectParams()
(un,pw,cs) = cp.parse_dsn_with_credentials("scott/tiger@localhost/orclpdb")

print(un)   # scott
print(pw)   # tiger
print(cs)   # localhost/orclpdb
Любой компонент, не найденный в DSN, возвращается как None .

Этот метод ConnectParams.get_network_service_names()можно использовать для получения списка имён сетевых служб, определённых в файле tnsnames.ora . Каталог, содержащий файл, можно указать в config_dirатрибуте.

cp = oracledb.ConnectParams(host="my_host", port=my_port, dsn="orclpdb",
                            config_dir="/opt/oracle/config")
cp.get_network_service_names()
Если ConnectParams.get_network_service_names()вызывается, но файл tnsnames.ora не существует, возвращается ошибка, подобная следующей:

DPY-4026: file tnsnames.ora not found in /opt/oracle/config
Если config_dirне указано, то возвращается следующая ошибка:

DPY-4027: no configuration directory specified
При создании автономного соединения (или пула соединений с классом PoolParams ) эквивалентное внутреннее извлечение выполняется автоматически, когда передается значение для dsnпараметра oracledb.connect(), oracledb.connect_async(), oracledb.create_pool(), или oracledb.create_pool_async(), но для параметра не передается никакого значения user.

4.6 Функции подключения
Python-oracledb поддерживает функции перехвата протокола, пароля и параметров, которые можно использовать для настройки логики подключения.

4.6.1 Использование функций перехвата протокола
Этот oracledb.register_protocol()метод регистрирует функцию-перехватчик пользовательского протокола, которая будет вызвана внутренним образом python-oracledb в режиме Thin перед созданием подключения или пула. Функция-перехватчик будет вызвана при вызове oracledb.connect(), oracledb.create_pool(), oracledb.connect_async(), или oracledb.create_pool_async()с префиксом dsnв виде указанного протокола. Ожидается, что ваша функция-перехватчик создаст корректные данные о подключении, которые python-oracledb будет использовать для завершения подключения или создания пула.

Вы также можете использовать функцию перехвата протокола в вызовах соединения в режиме Thick в python-oracledb, установив oracledb.defaults.thick_mode_dsn_passthroughзначение False . В качестве альтернативы ConnectParams.parse_connect_string()см. раздел Использование класса ConnectParams Builder .

Например, следующая функция-хук обрабатывает строки подключения с префиксом tcp://протокола. При oracledb.connect()вызове хук-пример вызывается внутри. Он выводит параметры и устанавливает информацию о подключении в paramsпараметре (без передачи tcp://префикса, parse_connect_string()иначе произошла бы рекурсия). Этот изменённый объект ConnectParams используется python-oracledb для установки соединения с базой данных:

def myprotocolhook(protocol, arg, params):
    print(f"In myprotocolhook: protocol={protocol} arg={arg}")
    params.parse_connect_string(arg)

oracledb.register_protocol("tcp", myprotocolhook)

connection = oracledb.connect(user="scott", password=userpwd,
                              dsn="tcp://localhost/orclpdb")

with connection.cursor() as cursor:
    for (r,) in cursor.execute("select user from dual"):
        print(r)
Результат будет следующим:

In myprotocolhook: protocol=tcp arg=localhost/orclpdb
SCOTT
Атрибуты можно задать с помощью , как показано, params илиConnectParams.parse_connect_string() с помощью ConnectParams.set().

Более полный пример см. в разделе Именование каталогов LDAP .

Внутренние функции перехвата протоколов TCP и TCPS зарегистрированы заранее, но при необходимости могут быть переопределены. Если какой-либо другой протокол не зарегистрирован, подключение приведёт к ошибке.

Вызов register_protocol()с hook_function параметром, установленным на None, приведет к удалению ранее зарегистрированной пользовательской функции и восстановлению поведения по умолчанию.

Хуки подключения и parse_connect_string()

Функция-хук зарегистрированного пользовательского протокола также будет вызываться в тонком и толстом режимах python-oracledb при ConnectParams.parse_connect_string()вызове с connect_stringпараметром, начинающимся с зарегистрированного протокола. paramsЗначением функции-хука будет вызывающий экземпляр ConnectParams, который можно обновить с помощью ConnectParams.set()или ConnectParams.parse_connect_string().

Например, с помощью myprotocolhookранее показанного хука, код будет выглядеть так:

cp = oracledb.ConnectParams()
cp.set(port=1234)
print(f"host is {cp.host}, port is {cp.port}, service name is {cp.service_name}")
cp.parse_connect_string("tcp://localhost/orclpdb")
print(f"host is {cp.host}, port is {cp.port}, service name is {cp.service_name}")
отпечатки:

host is None, port is 1234, service name is None
In myprotocolhook: protocol=tcp arg=localhost/orclpdb
host is localhost, port is 1234, service name is orclpdb
Если у вас есть приложение, которое может работать в режимах python-oracledb Thin или Thick, и вы хотите, чтобы зарегистрированная функция-перехватчик протокола соединения использовалась в обоих режимах, ваш код соединения может быть таким:

dsn = "tcp://localhost/orclpdb"

cp = oracledb.ConnectParams()
cp.parse_connect_string(dsn)
connection = oracledb.connect(user="hr", password=userpwd, params=cp)
4.6.2 Использование функций перехвата паролей
Этот oracledb.register_password_type()метод регистрирует функцию-перехватчик пароля пользователя, которая будет вызываться python-oracledb перед подключением или созданием пула при вызове oracledb.connect(), oracledb.create_pool(), oracledb.connect_async(), или . Если параметры , , , или этих методов представляют собой словарь, содержащий ключ «type», то будет вызвана зарегистрированная функция-перехватчик пароля пользователя для указанного типа. Ожидается, что ваша функция-перехватчик примет словарь и вернет строку с паролем.oracledb.create_pool_async()passwordnewpasswordwallet_password

Ниже приведён пример функции перехвата паролей, которая обрабатывает пароли типа base64, хранящиеся в словаре типа «dict(type='base64', value='dGlnZXI=')». Обратите внимание, что эта функция перехвата уже включена и зарегистрирована в python-oracledb:

def mypasswordhook(args):
    return base64.b64decode(args["value"].encode()).decode()

oracledb.register_password_type("base64", mypasswordhook)
При oracledb.connect()вызове, как показано ниже, внутренний хук-пример вызывается. Он декодирует строку в кодировке base64 в ключе «value» и возвращает пароль, который затем используется python-oracledb для установки соединения с базой данных:

connection = oracledb.connect(user="scott",
                              password=dict(type="base64", value="dGlnZXI="),
                              dsn="localhost/orclpdb")
Вызов register_password_type()с hook_function параметром None приведет к удалению ранее зарегистрированной пользовательской функции.

4.6.3 Использование функций перехвата параметров
Этот oracledb.register_params_hook()метод регистрирует функцию-перехват пользовательского параметра, которая будет вызвана python-oracledb перед подключением или созданием пула при вызове oracledb.connect(), oracledb.create_pool(), oracledb.connect_async(), или oracledb.create_pool_async(). Функция-перехват параметров должна принимать копию параметров, которые будут использоваться для создания пула или отдельных подключений. Функция может получать к ним доступ и изменять их любым необходимым способом, чтобы python-oracledb мог впоследствии завершить запрос на подключение или создание пула.

Предустановленные плагины python-oracledb, такие как плагин аутентификации OCI Cloud Native (oci_tokens), используют oracledb.register_params_hook(). Этот плагин использует информацию из параметра метода подключения extra_auth_paramsи изменяет этот access_tokenпараметр с помощью функции, которая получает токен аутентификации, необходимый для завершения подключения. Полную реализацию плагина см. в файле oci_tokens.py . Ключевой фрагмент кода, демонстрирующий регистрацию функции-хука параметров:

def oci_token_hook(params: oracledb.ConnectParams):

  if params.extra_auth_params is not None:

    def token_callback(refresh):
      return generate_token(params.extra_auth_params, refresh)

    params.set(access_token=token_callback)

oracledb.register_params_hook(oci_token_hook)
Затем ваш код может попытаться подключиться следующим образом:

token_based_auth = {
    "auth_type": "SimpleAuthentication",
    "user": <user>,
    "key_file": <key_file>,
    "fingerprint": <fingerprint>,
    "tenancy": <tenancy>,
    "region": <region>,
    "profile": <profile>
}

connection = oracledb.connect(
    dsn=mydb_low,
    extra_auth_params=token_based_auth)
Чтобы отменить регистрацию ранее зарегистрированной пользовательской функции, можно использовать oracledb.unregister_params_hook().

Если вы зарегистрировали пользовательские методы перехвата с помощью oracledb.register_protocol()и oracledb.register_params_hook(), то метод, зарегистрированный с помощью , oracledb.register_protocol()будет вызван первым при вызовах подключения или создания пула. При вызове ConnectParams.parse_connect_string()будет вызван зарегистрированный метод перехвата протокола, но метод перехвата параметров не будет вызван.

4.7. Именование каталогов LDAP
Служба именования каталогов централизует сетевые имена и адреса, используемые для подключений, в одном месте. Подробнее см. в разделах « Настройка клиентов Oracle Database для именования каталогов OID и OUD» и «Настройка клиентов Oracle Database для именования Microsoft Active Directory» .

Имя DSN для подключений LDAP может быть псевдонимом, как показано в приведенных выше ссылках. В качестве альтернативы, это может быть URL-адрес LDAP. Синтаксис URL устраняет необходимость во внешних sqlnet.oraфайлах LDAP и конфигурации. См. технический документ Oracle Client 23ai LDAP URL Syntax .

Псевдонимы LDAP в толстом режиме Python-oracledb

После настройки сервера каталогов и создания необходимых файлов конфигурации, как описано в приведенных выше ссылках, приложения python-oracledb в толстом режиме могут использовать псевдоним LDAP в качестве DSN-подключения python-oracledb:

connection = oracledb.connect(user="scott", password=pw, dsn="myLdapAlias")
Python-oracledb Толстые URL-адреса LDAP-режима

Приложения Python-oracledb в режиме «Толстый», использующие Oracle Client 23.4 или более поздней версии, могут подключаться по URL-адресу LDAP. Например:

ldapurl = "ldaps://ldapserver.example.com/cn=orcl,cn=OracleContext,dc=example,dc=com"
connection = oracledb.connect(user="scott", password=pw, dsn=ldapurl)
Для использования URL-адреса LDAP в режиме «Толстый» python-oracledb при oracledb.defaults.thick_mode_dsn_passthroughзначении False требуется функция подключения, как показано ниже для режима «Тонкий». Это позволяет использовать URL-адреса LDAP, когда python-oracledb использует любую поддерживаемую версию клиентской библиотеки Oracle.

URL-адреса LDAP тонкого режима Python-oracledb

Чтобы использовать LDAP в тонком режиме python-oracledb, oracledb.register_protocol()зарегистрируйте собственную функцию-хук пользовательского протокола подключения , которая получает строку подключения к базе данных с вашего LDAP-сервера. После этого ваше приложение сможет указывать URL-адрес LDAP в качестве имени домена (DSN) при вызовах подключения и создания пула.

Например:

import ldap3
import re

# Get the Oracle Database connection string from an LDAP server when
# connection calls use an LDAP URL.
# In this example, "protocol"' will have the value "ldap", and "arg" will
# be "ldapserver/dbname,cn=OracleContext,dc=dom,dc=com"

def ldap_hook(protocol, arg, params):
    pattern = r"^(.+)\/(.+)\,(cn=OracleContext.*)$"
    match = re.match(pattern, arg)
    ldap_server, db, ora_context = match.groups()

    server = ldap3.Server(ldap_server)
    conn = ldap3.Connection(server)
    conn.bind()
    conn.search(ora_context, f"(cn={db})", attributes=['orclNetDescString'])
    connect_string = conn.entries[0].orclNetDescString.value
    params.parse_connect_string(connect_string)

oracledb.register_protocol("ldap", ldap_hook)

connection = oracledb.connect(user="hr", password=userpwd,
             dsn="ldap://ldapserver/dbname,cn=OracleContext,dc=dom,dc=com")
При необходимости вы можете изменить или расширить его, например, чтобы использовать модуль LDAP, отвечающий вашим бизнес-требованиям и требованиям безопасности, обрабатывать LDAPS или кэшировать ответ от сервера LDAP.

4.8 Метаданные соединения и контексты приложений
Во время подключения можно задать дополнительные свойства метаданных, к которым можно получить доступ в базе данных для отслеживания и обеспечения детального доступа к данным, например, с помощью политик Oracle Virtual Private Database. Значения могут отображаться в журналах и аудиторских следах.

Атрибуты сквозной трассировки

Атрибуты соединения Connection.client_identifier, Connection.clientinfo, Connection.dbop, Connection.module, и Connection.actionзадают метаданные о соединении.

Рекомендуется всегда устанавливать как минимум client_identifier, module, и actionдля всех приложений, поскольку их наличие в базе данных может существенно помочь в устранении неполадок в будущем.

Дополнительную информацию см. в разделе Сквозная трассировка Oracle Database .

Контексты приложений

Контекст приложения хранит идентификационные данные пользователя, которые могут разрешить или запретить пользователю доступ к данным в базе данных. См. документацию Oracle AI Database « О контекстах приложения» .

Контекст состоит из пространства имён и пары «ключ-значение». Пространство имён CLIENTCONTEXT зарезервировано для использования с контекстами клиентских приложений, основанными на сеансах. Контексты устанавливаются во время подключения как массив из трёх кортежей, содержащих строковые значения пространства имён, ключа и значения. Например:

myctx = [
    ("clientcontext", "loc_id", "1900")
]

connection = oracledb.connect(user="hr", password=userpwd, dsn="dbhost.example.com/orclpdb",
                              appcontext=myctx)
Значения контекста, заданные во время подключения, можно напрямую запрашивать в приложениях. Например:

with connection.cursor() as cursor:
    sql = """select * from locations
             where location_id = sys_context('clientcontext', 'loc_id')"""
    for r in cursor.execute(sql):
        print(r)
Это напечатает:

(1900, '6092 Boxwood St', 'YSW 9T2', 'Whitehorse', 'Yukon', 'CA')
При подключении можно задать несколько значений контекста. Например:

myctx = [
    ("clientcontext", "loc_id", "1900"),
    ("clientcontext", "my_world", "earth"),
]

connection = oracledb.connect(user="hr", password=userpwd, dsn="dbhost.example.com/orclpdb",
                              appcontext=myctx)

with connection.cursor() as cursor:
    sql = """select sys_context('clientcontext', 'loc_id'),
                    sys_context('clientcontext', 'my_world')
             from dual"""
    for r in cursor.execute(sql):
        print(r)
отобразится:

('1900', 'earth')
Контексты позволяют настраивать ограничительные политики, которые автоматически применяются к любому выполняемому запросу. См. документацию по Oracle AI Database. Oracle Virtual Private Database (VPD) .

4.9. Объединение соединений
Пулы соединений могут значительно повысить производительность и масштабируемость приложений за счёт совместного использования ресурсов. Пулы также позволяют приложениям использовать дополнительные расширенные функции Oracle High Availability.

Открытие соединения с базой данных может быть дорогостоящим: необходимо проанализировать строку соединения, установить сетевое соединение, вызвать сетевой прослушиватель Oracle Database, выполнить аутентификацию пользователя, создать процесс сервера базы данных и выделить память сеанса (при этом процесс уничтожается при закрытии соединения). Пулы соединений устраняют накладные расходы, связанные с многократным открытием и закрытием отдельных соединений , создавая пул открытых соединений, которые можно использовать повторно на протяжении всего жизненного цикла процесса приложения.

В python-oracledb поддерживаются различные методы аутентификации Oracle Database, см. раздел Параметры аутентификации .

Для приложений python-oracledb доступны следующие решения по объединению данных:

Пулы подключений драйверов : управляются на уровне драйверов. Они обеспечивают легкодоступные подключения к базе данных, которые могут совместно использоваться несколькими пользователями и быстро устанавливаются приложениями. Они обеспечивают масштабируемость и высокую доступность приложений. Они создаются с помощью oracledb.create_pool()илиoracledb.create_pool_async().

Основной вариант использования — приложения, которые удерживают соединения относительно недолго, выполняя операции с базой данных, и которые по мере необходимости устанавливают и освобождают соединения в пуле для выполнения этих операций. Использование пула драйверов рекомендуется для приложений, требующих поддержки нескольких пользователей. Высокая доступность также делает пулы драйверов полезными для однопользовательских приложений, которые нечасто выполняют операции с базой данных.

Пул резидентных соединений базы данных (DRCP) : это пул серверных процессов на хосте базы данных для их совместного использования различными подключениями приложений. Это сокращает количество серверных процессов, которыми должен управлять хост базы данных.

DRCP полезен при наличии большого количества подключений приложений, обычно связанных с несколькими процессами, и при этом эти приложения часто выполняют запросы на установление и освобождение соединения, необходимые для выполнения операций с базой данных. Рекомендуется использовать DRCP совместно с пулом подключений драйверов, поскольку это сокращает количество повторных аутентификаций и перераспределений памяти сеанса.

Пул резидентных прокси-подключений (PRCP) : это пул подключений, управляемый решением Oracle для прокси-подключений среднего уровня — CMAN-TDM .

PRCP полезен для приложений, использующих преимущества CMAN-TDM.

Неявный пул соединений : это может дать преимущества пула приложениям, которые подключаются при запуске и закрывают соединение только после завершения работы, но при этом сравнительно редко выполняют операции с базой данных. Он использует протоколы DRCP или PRCP, но вместо того, чтобы полагаться на явное установление и завершение соединений приложением, неявный пул соединений автоматически определяет, когда приложения не выполняют операции с базой данных. Затем он позволяет использовать связанный процесс сервера базы данных другим подключением, которому необходимо выполнить операцию с базой данных.

Неявный пул соединений полезен для устаревших приложений или стороннего кода, который невозможно обновить для использования пула соединений драйверов.

Пулы соединений драйвера Python-oracledb — лучший выбор для обеспечения производительности, масштабируемости и высокой доступности. Если ваша база данных испытывает нехватку памяти из-за слишком большого количества приложений, открывающих слишком много соединений, рассмотрите вариант DRCP или Implicit Connection Pooling , в зависимости от жизненного цикла соединения вашего приложения. Если вы используете CMAN-TDM, можно рассмотреть вариант PRCP .

4.9.1. Объединение подключений драйверов
Пул соединений драйвера Python-oracledb позволяет приложениям создавать и поддерживать пул открытых подключений к базе данных. Пул соединений доступен как в тонком, так и в толстом режимах. Пул соединений важен для производительности и масштабируемости, когда приложениям необходимо обрабатывать большое количество пользователей, которые работают с базой данных в течение коротких периодов времени, но имеют относительно длительные периоды бездействия. Высокая доступность пулов также делает небольшие пулы полезными для приложений, которым требуется несколько подключений для нечастого использования, и которые должны быть готовы к использованию сразу после получения. Приложения, которым выгоден пул соединений, но которые слишком сложно модифицировать, используя отдельные соединения, могут использовать неявный пул соединений .

В режиме python-oracledb Thick реализация пула использует технологию пула сеансов Oracle , которая поддерживает дополнительные функции Oracle Database, например некоторые расширенные функции высокой доступности .

Примечание

Пулы соединений драйвера Python-oracledb должны создаваться, использоваться и закрываться в одном процессе. Совместное использование пулов или соединений между процессами может привести к непредсказуемому поведению.

Поддерживается использование пулов соединений в многопоточных архитектурах.

Архитектуры с несколькими процессами, которые нельзя преобразовать в потоковые, могут получить некоторые преимущества от использования резидентного пула соединений с базой данных (DRCP) .

4.9.1.1 Создание пула соединений
Пул подключений драйверов создаётся путём вызова oracledb.create_pool(). Можно указать различные параметры пула, как описано create_pool()и подробно описано ниже.

Например, чтобы создать пул, который изначально содержит одно соединение, но может расшириться до пяти соединений:

pool = oracledb.create_pool(user="hr", password=userpwd, dsn="dbhost.example.com/orclpdb",
                            min=1, max=5, increment=1)
4.9.1.2. Получение подключений из пула
После создания пула ваше приложение может получить из него соединение, вызвав ConnectionPool.acquire():

connection = pool.acquire()
Эти соединения можно использовать так же, как и автономные соединения .

По умолчанию acquire()вызовы ожидают появления соединения, прежде чем вернуться в приложение. Соединение будет доступно, если в пуле есть свободные соединения, когда другой пользователь вернёт соединение в пул или после увеличения пула. Ожидание позволяет приложениям быть устойчивыми к временным скачкам нагрузки на соединения. Пользователям может потребоваться некоторое время для установки соединения, но сбоев соединения не будет.

Вы можете изменить поведение, acquire()установив этот getmodeпараметр при создании пула. Например, можно настроить его так, чтобы, если все соединения в данный момент используются приложением, любой дополнительный acquire()вызов немедленно возвращал ошибку.

pool = oracledb.create_pool(user="hr", password=userpwd, dsn="dbhost.example.com/orclpdb",
                            min=2, max=5, increment=1,
                            getmode=oracledb.POOL_GETMODE_NOWAIT)
Обратите внимание, что при использовании этого значения параметра в режиме python-oracledb Thick с клиентскими библиотеками Oracle версии 12.2 или более ранней, вызов acquire() по-прежнему будет ожидать, если пул может увеличиться. Однако, если пул достигнет максимального размера, вы немедленно получите ошибку. С более новыми клиентскими библиотеками Oracle и в режиме Thin будет возвращена ошибка, если пул должен или не может увеличиться.

4.9.1.3 Возврат соединений в пул
Когда приложение завершит выполнение всех необходимых операций с базой данных, объединённое в пул соединение должно быть возвращено в пул, чтобы сделать его доступным для других пользователей. Например, вы можете использовать блок менеджера контекста with Python , который позволяет неявно закрывать объединённые в пул соединения по завершении области действия и очищать зависимые ресурсы:

with pool.acquire() as connection:
    with connection.cursor() as cursor:
        for result in cursor.execute("select * from mytab"):
            print(result)
В качестве альтернативы вы можете явно возвращать соединения с помощью ConnectionPool.release()или Connection.close(), однако вам может потребоваться сначала закрыть другие ресурсы.

Если вам необходимо принудительно закрыть соединение и освободить связанный с ним процесс сервера базы данных, используйте ConnectionPool.drop():

with pool.acquire() as connection:

    . . .

    pool.drop(connection)
Избегайте этого без необходимости, так как это приводит к сужению пула. При последующем acquire()вызове могут возникнуть накладные расходы на установление нового соединения с базой данных вместо возможности повторно использовать уже имеющееся в пуле соединение.

4.9.1.4 Закрытие пула соединений
При завершении работы приложения пул соединений можно полностью закрыть с помощью ConnectionPool.close():

pool.close()
Чтобы принудительно завершить работу пула, когда соединения все еще используются, выполните:

pool.close(force=True)
См. connection_pool.py для работающего примера организации пула соединений.

4.9.2 Использование кэша пула соединений
Если архитектура вашего приложения затрудняет передачу объекта ConnectionPool между слоями кода, вы можете использовать кэш пулов соединений python-oracledb. Это позволяет хранить и извлекать пулы по имени.

Добавление пула в кэш пула соединений python-oracledb

Чтобы использовать кэш пула python-oracledb, укажите этот pool_aliasпараметр при создании пула во время инициализации приложения. Его значение должно быть строкой, выбранной пользователем. Например:

import oracledb

NAME = "my_pool"

oracledb.create_pool(
    user="hr",
    password=userpwd,
    dsn="dbhost.example.com/orclpdb",
    pool_alias=NAME
)
Это создаёт пул и сохраняет его в кэше под именем «my_pool». Приложению не нужно хранить или управлять ссылкой на пул, поэтому create_pool()возвращаемое значение не сохраняется.

Если пул с именем «my_pool» уже существует, возникнет следующая ошибка:

DPY-2055: connection pool with name "my_pool" already exists
Получение соединения из кэшированного пула

Приложения могут получить соединение из кэшированного пула, передав его имя напрямую oracledb.connect():

import oracledb

NAME = "my_pool"

connection = oracledb.connect(pool_alias=NAME)
Это эквивалентно вызову ConnectionPool.acquire(). Вы можете передать дополнительные параметры, connect()разрешенные для acquire(). Например, в случае неоднородного пула можно передать имя пользователя и пароль:

import oracledb

NAME = "my_pool"

connection = oracledb.connect(pool_alias=NAME, user="toto", password=pw)
Если в кэше нет указанного пула my_pool, вы получите следующую ошибку:

DPY-2054: connection pool with name "my_pool" does not exist
Нельзя передавать pool_aliasи устаревший poolпараметр вместе в oracledb.connect()или oracledb.connect_async(). В противном случае возникнет следующая ошибка:

DPY-2014: "pool_alias" and "pool" cannot be specified together
Получение пула из кэша пула соединений

Вы можете использовать oracledb.get_pool()для извлечения пула и последующего прямого доступа к нему:

import oracledb

NAME = "my_pool"

pool = oracledb.get_pool(NAME)
connection = pool.acquire()
Это позволяет использовать любой метод пула соединений или атрибут из кэшированного пула, как обычно.

my_poolЕсли в кэше нет указанного пула , то get_pool()будет возвращено None.

Удаление пула из кэша

Пул автоматически удаляется из кэша при закрытии пула:

import oracledb

NAME = "my_pool"

pool = oracledb.get_pool(NAME)
pool.close()
4.9.3. Размер пула соединений
Группа Oracle Real-World Performance Group рекомендует использовать пулы соединений фиксированного размера. Значения minи maxдолжны быть одинаковыми. При использовании старых версий клиентских библиотек Oracle этот incrementпараметр должен быть равен нулю (что внутренне воспринимается как единица), но в противном случае может быть предпочтительнее больший размер, поскольку это повлияет на восстановление пула соединений, например, после того, как сбой в сети сделает все соединения недействительными.

Пулы фиксированного размера позволяют избежать штормов подключений в базе данных, которые могут снизить пропускную способность. Подробнее о размерах пулов см. в разделе Руководство по предотвращению штормов подключений: использование статических пулов . Фиксированный размер также гарантирует, что база данных сможет справиться с пулом большего размера. Например, если пул с динамическим размером должен увеличиваться, а ресурсы базы данных ограничены, ConnectionPool.acquire()могут возвращаться ошибки типа ORA-28547 , или база данных может просто сбрасывать попытки подключения, а python-oracledb будет показывать DPY-4011 . При фиксированном размере пула этот класс ошибок обычно возникает при его создании, что позволяет изменить его размер или перенастроить базу данных до того, как пользователи получат доступ к приложению. При динамически растущем пуле ошибка может возникнуть гораздо позже, во время использования приложения.

Real-World Performance Group также рекомендует выбирать пулы небольшого размера, поскольку они часто могут работать эффективнее пулов большего размера. Атрибуты пула следует корректировать для обеспечения требуемой нагрузки в рамках доступных ресурсов python-oracledb и базы данных.

4.9.3.1. Рост пула соединений
При создании пула minустанавливаются подключения к базе данных. При необходимости расширения пула новые подключения создаются автоматически, ограниченные его размером max. Размер пула maxограничивает количество пользователей приложений, которые могут параллельно работать с базой данных.

Количество открытых пулом соединений можно отобразить с помощью атрибута . ConnectionPool.openedКоличество соединений, полученных приложением, acquire()можно отобразить с помощью атрибута ConnectionPool.busy. Разница в значениях представляет собой количество неиспользуемых или «простаивающих» соединений в пуле. Эти простаивающие соединения могут быть закрыты пулом в зависимости от его конфигурации.

Увеличение пула обычно инициируется при acquire()вызове и отсутствии в пуле неиспользуемых соединений, которые можно было бы вернуть приложению. Количество новых внутренних соединений будет равно значению create_pool()параметра increment.

В зависимости от используемого режима (Thin или Thick) и getmodeустановленного значения создания пула, любой acquire()вызов, инициирующий рост пула, может ожидать, пока все incrementновые соединения не будут открыты внутренне. Однако в этом случае затраты амортизируются, поскольку последующие acquire()вызовы могут не ждать и могут немедленно вернуть доступное соединение. Некоторые пользователи устанавливают большие incrementзначения даже для пулов фиксированного размера, поскольку это может помочь пулу восстановиться, если все соединения станут недействительными, например, после отключения сети. В общем случае тонкого режима со значением по умолчанию getmode любой oracledb.POOL_GETMODE_WAITвызов, acquire() инициирующий рост пула, вернется после создания первого нового соединения, независимо от его размера increment. После этого пул продолжит восстанавливать соединения в фоновом потоке.

Пул соединений может уменьшиться до минимального размера, minкогда открытые им соединения не используются приложением. Это освобождает ресурсы базы данных, позволяя пулам сохранять открытые соединения для активных пользователей. Если minоткрытых соединений больше, чем , и соединения простаивают в пуле (т.е. не используются приложением в данный момент) и не используются дольше, чем указано в атрибуте создания пула timeout, то они будут закрыты. Проверка выполняется через каждый timeoutинтервал, поэтому в худшем случае timeoutзакрытие простаивающих соединений может занять вдвое больше времени. Значение по умолчанию timeout— 0 секунд, что означает бесконечное время, то есть простаивающие соединения никогда не будут закрыты.

Параметр создания пула max_lifetime_sessionтакже позволяет сжимать пулы. Этот параметр ограничивает общую продолжительность существования соединения с момента его создания в пуле. Он в основном используется в защитном программировании для предотвращения непредвиденных проблем, которые могут возникнуть с соединениями. Если соединение было создано max_lifetime_sessionнесколько секунд назад или более, оно будет кандидатом на закрытие. В случае, если установлены оба параметра timeoutи max_lifetime_session, соединение будет разорвано либо при истечении тайм-аута простоя, либо при превышении максимального времени жизни. Обратите внимание, что при использовании python-oracledb в режиме Thick с клиентскими библиотеками Oracle до версии 21c сжатие пула инициируется только при обращении к пулу, поэтому пулы в полностью неактивных приложениях не будут сжиматься до следующего использования приложения. В режиме Thick для использования требуются клиентские библиотеки Oracle версии 12.1 или более поздней max_lifetime_session.

Для пулов, созданных с внешней аутентификацией , с параметром homogen , установленным в значение False, или при использовании резидентного пула соединений с базой данных (DRCP) (в режиме python-oracledb Thick), количество открытых при создании пула соединений равно нулю, даже если для указано большее значение min. Кроме того, в этих случаях единица приращения пула всегда равна 1 независимо от значения increment.

4.9.4. Состояние подключения к пулу
Перед ConnectionPool.acquire()возвратом python-oracledb выполняет лёгкую проверку, аналогичную той, что используется Connection.is_healthy()для проверки того, открыт ли сетевой транспорт для выбранного соединения. Если нет, acquire()соединение очищается и возвращается другое.

Эта проверка не обнаружит такие случаи, как завершение сеанса базы данных администратором базы данных или достижение квоты диспетчера ресурсов базы данных. В таких случаях acquire()также будет выполнен полный круговой пинг базы данных, аналогичный тому, который Connection.ping()выполняется при попытке вернуть соединение, простаивавшее в пуле (т.е. не захваченное приложением) в течение ConnectionPool.ping_intervalнескольких секунд. В случае неудачи пинга соединение будет разорвано, и будет получено другое, прежде чем acquire()приложение вернется к работе. ping_timeoutПараметр to oracledb.create_pool()ограничивает время выполнения любого внутреннего пинга. Если это время превышено, например, из-за зависания сети, соединение считается неиспользуемым, и приложению возвращается другое соединение.

Поскольку этот полный пинг привязан ко времени и может не срабатывать для каждого acquire(), приложение всё равно может столкнуться с неиспользуемым соединением. Кроме того, между вызовами acquire()и могут возникать сетевые тайм-ауты и прерывание сеанса Cursor.execute(). Для обработки таких случаев приложениям необходимо проверять наличие ошибок после каждого вызова execute()и принимать решения о повторной попытке работы в случае сбоя соединения, специфичные для конкретного приложения. При использовании python-oracledb в режиме Thick функции Oracle Database, такие как Application Continuity, могут делать это автоматически в некоторых случаях.

Вы можете в любой момент явно инициировать полный круговой пинг Connection.ping()для проверки работоспособности соединения, но его чрезмерное использование скажется на производительности и масштабируемости. Чтобы избежать зависания пингов из-за сетевых ошибок, используйте , чтобы ограничить допустимое Connection.call_timeoutвремя выполнения.ping()

Этот Connection.is_healthy()метод является альтернативой Connection.ping(). Он требует меньших накладных расходов и может подойти для некоторых применений, но не выполняет полную проверку соединения.

Если getmodeпараметр in oracledb.create_pool()установлен в значение oracledb.POOL_GETMODE_TIMEDWAIT, то максимальное время acquire()ожидания вызова для получения соединения из пула ограничено значением параметра ConnectionPool.wait_timeout . Вызов, который не может быть выполнен немедленно, будет ожидать не дольше, чем , wait_timeoutнезависимо от значения ping_timeout.

На работоспособность пула подключений могут влиять брандмауэры , менеджеры ресурсов и значения IDLE_TIME в профилях пользователей . Для максимальной эффективности убедитесь, что они не приводят к завершению сеансов бездействия, так как это потребует пересоздания подключений, что скажется на производительности и масштабируемости.

Восстановление внутреннего соединения пула после коротких и полных пингов может скрывать проблемы конфигурации, влияющие на производительность, такие как разрыв соединений брандмауэрами. Следите за отчётами AWR на предмет неожиданно высокой скорости подключения.

4.9.5. Реконфигурация пула соединений
Некоторые настройки пула можно изменять динамически с помощью ConnectionPool.reconfigure(). Это позволяет изменять размер пула и другие атрибуты во время работы приложения без необходимости перезапуска пула или приложения.

Например, размер пула можно изменить следующим образом:

pool.reconfigure(min=10, max=10, increment=0)
После обработки любого изменения размера выполняется последовательная перенастройка остальных параметров. Если при изменении одного атрибута возникает ошибка, например, недопустимое значение, генерируется исключение, но все уже изменённые атрибуты сохраняют свои новые значения.

Во время перенастройки размера пула поведение ConnectionPool.acquire()зависит от значения создания пула, getmodeдействующего на момент acquire()вызова, см ConnectionPool.reconfigure(). . Закрытие подключений или закрытие пула будет отложено до завершения перенастройки пула.

Вызов reconfigure()— единственный способ изменить значения пула min, max и increment. Другие атрибуты, такие как , wait_timeoutможно передать reconfigure()или задать напрямую, например:

pool.wait_timeout = 1000
4.9.6 Обратные вызовы сеанса для установки состояния пула соединений
Приложения могут устанавливать состояние «сеанса» для каждого соединения. Примерами состояния сеанса являются настройки глобализации NLS из операторов. Соединения в пуле сохраняют состояние сеанса после возвращения в пул. Однако, поскольку пулы могут расширяться, а соединения в пуле могут создаваться заново, нет гарантии, что последующий вызов вернёт соединение с базой данных с каким-либо определённым состоянием.ALTER SESSIONacquire()

Этот create_pool()параметр session_callbackпозволяет эффективно настраивать состояние сеанса, чтобы соединения имели известное состояние сеанса, не требуя его явного задания после каждого acquire()вызова. Обратный вызов выполняется автоматически при acquire()вызове и выполняется первым.

Обратный вызов сеанса может быть функцией Python или процедурой PL/SQL.

Подключения также можно помечать тегами при возвращении их обратно в пул. Тег — это определяемая пользователем строка, представляющая состояние сеанса. При получении подключений можно запросить определённый тег. Если подключение с этим тегом доступно, оно будет возвращено. Если нет, будет возвращён другой сеанс. Сравнивая фактические и запрошенные теги, приложения могут определить точное состояние сеанса и внести необходимые изменения.

Тегирование подключений и обратные вызовы PL/SQL доступны только в режиме python-oracledb Thick. Обратные вызовы Python можно использовать в режимах python-oracledb Thin и Thick.

Существует три распространенных сценария session_callback:

Когда все соединения в пуле должны иметь одинаковое состояние, используйте обратный вызов Python без тегов.

Если соединения в пуле требуют разного состояния для разных пользователей, используйте обратный вызов Python с тегами.

При использовании пула резидентных соединений с базой данных (DRCP) используйте обратный вызов PL/SQL с тегированием.

4.9.6.1. Обратный вызов Python
Если session_callbackпараметр представляет собой процедуру Python, она будет вызываться каждый раз, когда acquire()будет возвращаться новое соединение с базой данных, которое ранее не использовалось. Она также вызывается, когда используется тегирование соединений, и запрошенный тег не совпадает с тегом в соединении, возвращаемом пулом.

Вот пример:

# Set the NLS_DATE_FORMAT for a session
def init_session(connection, requested_tag):
    with connection.cursor() as cursor:
        cursor.execute("alter session set nls_date_format = 'YYYY-MM-DD HH24:MI'")

# Create the pool with session callback defined
pool = oracledb.create_pool(user="hr", password=userpwd, dsn="localhost/orclpdb",
                            session_callback=init_session)

# Acquire a connection from the pool (will always have the new date format)
connection = pool.acquire()
При необходимости init_session()процедура вызывается внутри перед acquire()возвратом. Она не будет вызвана при возврате ранее использованных соединений из пула. Это означает, что ALTER SESSION не нужно выполнять после каждого acquire()вызова. Это повышает производительность и масштабируемость.

В этом примере тегирование не использовалось, поэтому requested_tagпараметр игнорируется.

Обратите внимание: если вам нужно выполнить несколько SQL-операторов в обратном вызове, используйте анонимный блок PL/SQL, чтобы избежать циклов повторных execute()вызовов. С помощью ALTER SESSION передайте несколько параметров в одном операторе:

cursor.execute("""
        begin
            execute immediate
                    'alter session set nls_date_format = ''YYYY-MM-DD''
                                       nls_language = AMERICAN';
            -- other SQL statements could be put here
        end;""")
4.9.6.2. Тегирование соединений
Тегирование соединений используется, когда соединения в пуле должны иметь разные состояния сеанса. Чтобы получить соединение с требуемым состоянием, необходимо установить tagатрибут .acquire()

Примечание

Тегирование подключений поддерживается только в режиме python-oracledb Thick. См. раздел Включение режима python-oracledb Thick .

Если python-oracledb использует клиентские библиотеки Oracle версии 12.2 или более поздней, то python-oracledb использует «теги со многими свойствами», а строка тега должна иметь форму одной или нескольких пар «имя=значение», разделенных точкой с запятой, например "loc=uk;lang=cy".

Если запрашивается соединение с заданным тегом, а соединение с этим тегом отсутствует в пуле, то пул выберет новое соединение или существующее соединение с очищенным состоянием сеанса, и будет вызвана процедура обратного вызова сеанса. Эта процедура обратного вызова затем может установить желаемое состояние сеанса и обновить тег соединения. Однако, если параметр matchanytagравен acquire()True, пул может выбрать любое другое тегированное соединение, и процедура обратного вызова должна проанализировать фактические и запрошенные теги, чтобы определить, какие биты состояния сеанса следует сбросить.

В примере ниже демонстрируется маркировка соединений:

def init_session(connection, requested_tag):
    if requested_tag == "NLS_DATE_FORMAT=SIMPLE":
        sql = "ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD'"
    elif requested_tag == "NLS_DATE_FORMAT=FULL":
        sql = "ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI'"
    cursor = connection.cursor()
    cursor.execute(sql)
    connection.tag = requested_tag

pool = oracledb.create_pool(user="hr", password=userpwd, dsn="orclpdb",
                             session_callback=init_session)

# Two connections with different session state:
connection1 = pool.acquire(tag="NLS_DATE_FORMAT=SIMPLE")
connection2 = pool.acquire(tag="NLS_DATE_FORMAT=FULL")
См. пример session_callback.py .

4.9.6.3. Обратный вызов PL/SQL
Примечание

Обратные вызовы PL/SQL поддерживаются только в режиме Thick в python-oracledb. См. раздел Включение режима Thick в python-oracledb .

Если python-oracledb использует Oracle Client 12.2 или более позднюю версию, обратный вызов сеанса также может быть именем процедуры PL/SQL. Обратный вызов PL/SQL будет инициирован только в том случае, если тег, связанный с соединением, не соответствует запрошенному тегу. Обратный вызов PL/SQL наиболее полезен при использовании резидентного пула соединений базы данных (DRCP), поскольку DRCP не требует полного обхода для вызова процедуры обратного вызова сеанса PL/SQL.

Обратный вызов сеанса PL/SQL должен принимать два аргумента VARCHAR2:

PROCEDURE myPlsqlCallback (
    requestedTag IN  VARCHAR2,
    actualTag    IN  VARCHAR2
);
Логика этой процедуры анализирует фактический тег в сеансе, выбранном пулом, и сравнивает его с тегом, запрошенным приложением. Затем процедура может изменить любое необходимое состояние, прежде чем соединение будет возвращено приложению из acquire().

Если matchanytagатрибут равен acquire()True , то пул может выбрать соединение с любым состоянием.

Необходимо использовать «многосвойственные теги» Oracle. Строка тега должна состоять из одной или нескольких пар «имя=значение», разделённых точкой с запятой, например "loc=uk;lang=cy", .

В python-oracledb укажите session_callbackимя процедуры PL/SQL. Например:

pool = oracledb.create_pool(user="hr", password=userpwd,
                             dsn="dbhost.example.com/orclpdb:pooled",
                             session_callback="MyPlsqlCallback")

connection = pool.acquire(tag="NLS_DATE_FORMAT=SIMPLE",
                          # DRCP options, if you are using DRCP
                          cclass='MYCLASS',
                          purity=oracledb.PURITY_SELF)
См. пример session_callback_plsql.py .

4.9.7. Гетерогенные и гомогенные пулы соединений
Однородные бассейны

По умолчанию пулы подключений являются «однородными», то есть все подключения используют одни и те же учётные данные базы данных. Оба режима python-oracledb (Thin и Thick) поддерживают однородные пулы.

Гетерогенные бассейны

Режим python-oracledb Thick дополнительно поддерживает гетерогенные пулы, позволяя передавать разные имена пользователей и пароли при каждом acquire()вызове.

Чтобы создать неоднородный пул, установите create_pool() параметр homogeneousна False:

pool = oracledb.create_pool(dsn="dbhost.example.com/orclpdb", homogeneous=False)
connection = pool.acquire(user="hr", password=userpwd)
4.9.8 Использование класса-конструктора PoolParams
Класс PoolParams позволяет определить параметры подключения и пула в одном месте. Функция oracledb.PoolParams()возвращает объект PoolParams . Это подкласс класса ConnectParams (см. раздел Использование класса-конструктора ConnectParams ) с дополнительными атрибутами, специфичными для пула, такими как максимальный размер пула. PoolParamsОбъект можно передать в oracledb.create_pool(). Например:

pp = oracledb.PoolParams(min=1, max=2, increment=1)
pool = oracledb.create_pool(user="hr", password=userpw, dsn="dbhost.example.com/orclpdb",
                            params=pp)
Использование класса PoolParams необязательно, поскольку те же параметры можно передать непосредственно в create_pool(). Например, код выше эквивалентен следующему:

pool = oracledb.create_pool(user="hr", password=userpw, dsn="dbhost.example.com/orclpdb",
                            min=1, max=2, increment=1)
Некоторые значения, такие как имя хоста базы данных, можно указать в качестве oracledb.create_pool()параметров, в составе dsnстроки подключения и в paramsобъекте. Окончательная строка подключения формируется на основе любых параметров dsn, отдельных параметров и paramsзначений объекта. Приоритет заключается в том, что значения в dsnпараметре переопределяют значения, переданные как отдельные параметры, которые, в свою очередь, переопределяют значения, заданные в paramsобъекте.

Большинство аргументов PoolParams можно получить как свойства. Их можно задать индивидуально с помощью set()метода:

pp = oracledb.PoolParams()
pp.set(min=5)
print(pp.min) # 5
4.10. Пул резидентных соединений базы данных (DRCP)
Технология резидентного пула соединений с базой данных (DRCP) обеспечивает совместное использование ресурсов базы данных приложениями, использующими большое количество соединений, которые выполняются в нескольких клиентских процессах или на нескольких серверах приложений среднего уровня. По умолчанию каждое соединение из Python будет использовать один процесс сервера базы данных. DRCP позволяет объединять эти серверные процессы в пул. Это уменьшает объём памяти, требуемый на хосте базы данных. Пул DRCP может использоваться несколькими приложениями совместно.

DRCP полезен для приложений, которые используют одни и те же учетные данные базы данных, имеют схожие настройки сеанса (например, настройки формата даты или состояние пакета PL/SQL) и когда приложение получает соединение с базой данных, работает с ней в течение относительно короткого периода времени, а затем освобождает ее.

Для повышения эффективности рекомендуется использовать DRCP-подключения совместно с локальным пулом подключений python-oracledb . Использование DRCP с отдельными подключениями не столь эффективно, но позволяет базе данных повторно использовать процессы сервера базы данных, что может повысить производительность приложений, не использующих локальный пул подключений. В этом случае обязательно настройте достаточное количество серверов аутентификации DRCP для обработки нагрузки.

Хотя приложения могут выбирать, использовать ли пул DRCP-подключений во время выполнения, необходимо тщательно настроить базу данных с учётом ожидаемого количества подключений, а также предотвратить непреднамеренное использование не-DRCP-подключений, приводящее к нехватке ресурсов сервера базы данных. И наоборот, избегайте использования DRCP-подключений для длительных операций.

Дополнительные сведения о DRCP см. в техническом описании Extreme Oracle Database Connection Scalability with Database Resident Connection Pooling (DRCP) , в пользовательской документации Oracle AI Database Concepts Guide , а сведения о настройке DRCP см. в руководстве Oracle AI Database Administrator's Guide .

Использование DRCP с приложениями python-oracledb включает следующие шаги:

Включение DRCP в базе данных

Настройка приложения для использования пула серверов DRCP

4.10.1 Включение DRCP в базе данных Oracle
Версии Oracle Database до 21c могут иметь один пул соединений DRCP. Начиная с Oracle Database 21c, каждая подключаемая база данных может иметь свой собственный пул или использовать пул уровня контейнера. Начиная с Oracle Database 23.4, можно создавать несколько пулов на уровне подключаемой или контейнерной базы данных. Эта функция многопуловой работы полезна, когда разные приложения подключаются к одной и той же базе данных, но существует опасение, что использование пула одним приложением может повлиять на работу других приложений. В противном случае использование одного пула может обеспечить оптимальное распределение ресурсов на хосте базы данных.

Обратите внимание, что DRCP уже включен в Oracle Autonomous Database, а управление пулом отличается от описанных ниже шагов.

В базовом сценарии пулы DRCP могут быть настроены и администрированы администратором баз данных с помощью DBMS_CONNECTION_POOLпакета:

EXECUTE DBMS_CONNECTION_POOL.CONFIGURE_POOL(
    pool_name => 'SYS_DEFAULT_CONNECTION_POOL',
    minsize => 4,
    maxsize => 40,
    incrsize => 2,
    session_cached_cursors => 20,
    inactivity_timeout => 300,
    max_think_time => 600,
    max_use_session => 500000,
    max_lifetime_session => 86400)
Альтернативно, метод DBMS_CONNECTION_POOL.ALTER_PARAM()может задать один параметр:

EXECUTE DBMS_CONNECTION_POOL.ALTER_PARAM(
    pool_name => 'SYS_DEFAULT_CONNECTION_POOL',
    param_name => 'MAX_THINK_TIME',
    param_value => '1200')
Этот inactivity_timeoutпараметр останавливает работу неиспользуемых серверов пула, помогая оптимизировать ресурсы базы данных. Чтобы избежать постоянного удержания серверов пула эгоистичным скриптом Python, max_think_timeможно задать параметр . Параметры num_cbrokи maxconn_cbrokможно использовать для распределения постоянных подключений клиентов между несколькими брокерами. Это может потребоваться в случаях, когда ограничение числа дескрипторов на процесс в операционной системе невелико. Некоторые клиенты обнаружили, что наличие нескольких брокеров подключений повышает производительность. Параметры max_use_sessionи помогают защититься от непредвиденных проблем, влияющих на серверные процессы. Значения по умолчанию подойдут большинству пользователей. Подробную информацию о параметрах max_lifetime_session см. в документации Oracle DRCP .

В общем случае, если параметры пула изменились, его следует перезапустить. В противном случае серверные процессы продолжат использовать старые настройки.

Существует DBMS_CONNECTION_POOL.RESTORE_DEFAULTS()процедура сброса всех значений.

При использовании DRCP с Oracle RAC каждый экземпляр базы данных имеет собственный брокер подключений и пул серверов. Каждый пул имеет идентичную конфигурацию. Например, все пулы запускаются с minsizeсерверными процессами. Одна команда DBMS_CONNECTION_POOL одновременно изменит пул каждого экземпляра. Пул необходимо запустить до начала запросов на подключение. Приведённая ниже команда делает это, запуская брокера, который регистрируется в прослушивателе базы данных:

EXECUTE DBMS_CONNECTION_POOL.START_POOL()
После включения таким образом пул автоматически перезапускается при перезапуске экземпляра базы данных, если только он явно не остановлен командой DBMS_CONNECTION_POOL.STOP_POOL():

EXECUTE DBMS_CONNECTION_POOL.STOP_POOL()
Oracle Database версии 23 позволяет DRAINTIMEпередавать аргумент STOP_POOL(), указывающий, что пул будет закрыт только по истечении указанного времени. Это позволяет продолжить выполнение текущих задач приложения. Значение draintime, равное 0, можно использовать для немедленного закрытия пула. См. документацию по базе данных, посвященную методу DBMS_CONNECTION_POOL.STOP_POOL() .

В старых версиях базы данных пул не мог быть остановлен, пока открыты соединения.

4.10.2. Кодирование приложений для использования DRCP
Для использования DRCP при установлении соединения приложение должно запросить сервер из пула DRCP и указать имя класса соединения, выбранное пользователем. При желании можно указать «чистоту» состояния сеанса соединения. Подробнее о преимуществах масштабируемости см. в документации Oracle Database .

Рекомендуется использовать DRCP совместно с локальным пулом подключений драйвера , созданным с помощью oracledb.create_pool(). oracledb.create_pool_async()Размер пула подключений python-oracledb не обязательно должен совпадать с размером пула DRCP. Ограничение на общий параллелизм выполнения определяется размером пула DRCP. Обратите внимание, что при использовании DRCP с локальным пулом подключений python-oracledb в режиме Thick значение локального пула подключений minигнорируется, и пул будет создан с нулевым количеством подключений.

См. drcp_pool.py для работающего примера DRCP.

Запрос на использование объединенных серверов

Чтобы разрешить подключениям использовать серверы пула DRCP, вы можете:

Используйте специальную строку подключения в oracledb.create_pool()или oracledb.connect()для запроса пула серверов. Например, с помощью синтаксиса Easy Connect :

pool = oracledb.create_pool(user="hr", password=userpwd, dsn="dbhost.example.com/orclpdb:pooled",
                            min=2, max=5, increment=1,
                            cclass="MYAPP")
В качестве альтернативы добавьте (SERVER=POOLED)к дескриптору подключения , который используется в файле конфигурации Oracle Network tnsnames.ora :

customerpool = (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)
          (HOST=dbhost.example.com)
          (PORT=1521))(CONNECT_DATA=(SERVICE_NAME=CUSTOMER)
          (SERVER=POOLED)))
Другой способ использования сервера пула DRCP — задать server_type параметр при создании отдельного соединения или пула соединений python-oracledb. Например:

pool = oracledb.create_pool(user="hr", password=userpwd, dsn="dbhost.example.com/orclpdb",
                            min=2, max=5, increment=1,
                            server_type="pooled",
                            cclass="MYAPP")
Классы соединений DRCP

Рекомендуется указывать cclassимя класса при создании пула соединений python-oracledb. Это имя, выбранное пользователем, обеспечивает разбиение памяти сеанса DRCP, что позволяет ограничить повторное использование только похожими приложениями. Это обеспечивает максимальное совместное использование пула при запуске нескольких процессов приложений с использованием одного и того же имени класса. Имя класса также позволяет лучше отслеживать использование DRCP в базе данных. В представлениях мониторинга базы данных отображаемое имя класса будет представлять собой значение, указанное в приложении, с префиксом в виде имени пользователя.

Если cclassэто не было указано при создании пула, то режим python-oracledb Thin генерирует уникальный класс подключения с префиксом «DPY», а режим python-oracledb Thick генерирует уникальный класс подключения с префиксом «OCI».

Чтобы создать пул соединений с запросом на использование серверов пула DRCP и указанием имени класса, можно вызвать:

pool = oracledb.create_pool(user="hr", password=userpwd, dsn="dbhost.example.com/orclpdb:pooled",
                            min=2, max=5, increment=1,
                            cclass="MYAPP")
Если cclassэтот параметр не установлен, то объединенные сеансы сервера не будут оптимально повторно использоваться, а в представлениях статистики DRCP могут регистрироваться большие значения NUM_MISSES.

Чистота соединения DRCP

DRCP позволяет повторно использовать или очищать память сеанса соединения при каждом получении соединения из пула. purityПараметр создания пула или соединения может быть одним из следующих PURITY_NEW: , PURITY_SELF, или PURITY_DEFAULT. Значение PURITY_SELFпозволяет повторно использовать как серверный процесс в пуле, так и память сеанса, обеспечивая максимальную эффективность DRCP. По умолчанию соединения в пуле python-oracledb используют , PURITY_SELFа отдельные соединения — PURITY_NEW.

Чтобы ограничить совместное использование сеанса, можно явно потребовать выделения новой памяти для сеанса при каждом вызове acquire(). Это можно сделать при создании пула подключений драйверов, указав purityследующее PURITY_NEW:

pool = oracledb.create_pool(user="hr", password=userpwd, dsn="dbhost.example.com/orclpdb:pooled",
                            min=2, max=5, increment=1,
                            cclass="MYAPP", purity=oracledb.PURITY_NEW)
Накладные расходы могут повлиять на конечную масштабируемость.

Имена пулов DRCP

Начиная с версии Oracle Database 23.4, можно создавать несколько пулов DRCP, указав имя пула при его создании. Приложения, использующие режим Thin в python-oracledb, могут указать, какой пул DRCP использовать, передав соответствующий pool_nameпараметр при создании соединения или пула соединений, например:

pool = oracledb.create_pool(user="hr", password=userpwd,
                            dsn="dbhost.example.com/orclpdb:pooled",
                            min=2, max=5, increment=1,
                            cclass="MYAPP", pool_name="MYPOOL")
При указании имени пула вам все равно следует задать имя класса соединения, чтобы обеспечить эффективное использование ресурсов пула.

Если вы используете режим python-oracledb Thick и thick_mode_dsn_passthroughдействующим значением является True , вы можете использовать pool_nameпараметр только в том случае, если dsnпараметр не указан при создании автономного или объединенного соединения, например:

oracledb.init_oracle_client()

pool = oracledb.create_pool(user="hr", password=userpwd,
                            host="localhost", service_name="orclpdb",
                            server_type="pooled", min=2, max=5,
                            increment=1, cclass="MYAPP",
                            pool_name="MYPOOL")
Если при использовании толстого режима заданы оба параметра pool_nameи , параметр игнорируется.dsnpool_name

Для толстого режима вы можете предпочесть установить параметр Oracle Net Services POOL_NAME в строке простого подключения или дескрипторе подключения , например:

oracledb.init_oracle_client()

pool = oracledb.create_pool(user="hr", password=userpwd,
                            dsn="dbhost.example.com/orclpdb:pooled?pool_name=mypool",
                            min=2, max=5, increment=1,
                            cclass="MYAPP")
Имя пула DRCP также можно определить с помощью класса ConnectParams при использовании тонкого или толстого режима python-oracledb. См. раздел Использование класса ConnectParams Builder .

Получение DRCP-соединения

После включения DRCP и создания пула подключений драйверов с соответствующей строкой подключения ваше приложение может получить соединение, использующее DRCP, вызвав:

connection = pool.acquire()
Имена классов соединений также можно передавать, acquire() если вы хотите использовать соединение с другим классом:

pool = oracledb.create_pool(user="hr", password=userpwd, dsn="dbhost.example.com/orclpdb:pooled",
                            min=2, max=5, increment=1,
                            cclass="MYAPP")

connection = mypool.acquire(cclass="OTHERAPP")
Если сервер пула запрошенного класса недоступен, используется сервер с новым состоянием сеанса. Если пул DRCP не может расширяться, можно использовать сервер с другим классом, а его состояние сеанса очистить.

Закрытие соединений при использовании DRCP

Аналогично использованию пула соединений python-oracledb, скрипты Python, в которых соединения python-oracledb не выходят из области действия быстро (что приводит к их освобождению), или в настоящее время не используются, Connection.close()или ConnectionPool.release()их следует проверить на возможность более раннего закрытия. Это позволяет другим пользователям максимально использовать серверы из пула DRCP:

pool = oracledb.create_pool(user="hr", password=userpwd, dsn="dbhost.example.com/orclpdb:pooled",
                            min=2, max=5, increment=1,
                            cclass="MYAPP")

# Do some database operations
connection = mypool.acquire()
. . .
connection.close()              # <- Add this to release the DRCP pooled server

# Do lots of non-database work
. . .

# Do some more database operations
connection = mypool.acquire()   # <- And get a new pooled server only when needed
. . .
connection.close()
4.10.3 Настройка параметров DRCP в строках подключения
Предпочтительнее задавать класс соединения DRCP, уровень чистоты и имя пула в качестве параметров функции в приложении, но иногда невозможно изменить существующую кодовую базу. В таких приложениях можно указать значения вместе с опцией сервера пула в строке подключения.

При использовании Oracle Database 21c и более поздних версий можно указать параметры класса и чистоты в строках подключения. При использовании Oracle Database 23.4 и более поздних версий можно указать имя пула.

Например, с синтаксисом Easy Connect :

dbhost.example.com/orclpdb:pooled?pool_connection_class=MYAPP&pool_purity=self&pool_name=MYPOOL
Или с помощью псевдонима TNS в файле tnsnames.ora :

customerpool = (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)
          (HOST=dbhost.example.com)
          (PORT=1521))(CONNECT_DATA=(SERVICE_NAME=orclpdb)
          (SERVER=POOLED)
          (POOL_CONNECTION_CLASS=MYAPP)
          (POOL_PURITY=SELF)
          (POOL_NAME=MYPOOL)))
Явное указание чистоты как SELF в строке подключения может привести к тому, что некоторые неиспользуемые соединения в пуле соединений python-oracledb в режиме Thick не будут завершены, что в конечном итоге может привести к тому, что все соединения в пуле станут непригодными. Если вы не можете программно задать имя класса и чистоту или не можете использовать режим Thin python-oracledb, избегайте явного указания чистоты в качестве параметра строки подключения при использовании локального пула соединений python-oracledb в режиме Thick.

4.10.4 Мониторинг DRCP
Для мониторинга производительности DRCP доступны представления словаря данных. Администраторы баз данных могут проверять статистику, такую ​​как количество занятых и свободных серверов, а также количество попаданий и промахов в пуле по сравнению с общим количеством запросов от клиентов. Представления включают:

DBA_CPOOL_INFO

V$ПРОЦЕСС

V$СЕССИЯ

V$CPOOL_STATS

V$CPOOL_CC_STATS

V$CPOOL_CONN_INFO

DBA_CPOOL_INFO Просмотр

DBA_CPOOL_INFO отображает информацию о конфигурации пула DRCP. Столбцы эквивалентны настройкам dbms_connection_pool.configure_pool() , описанным в таблице параметров конфигурации DRCP, с добавлением столбца STATUS. Статус указывает, ACTIVEзапущен ли пул, и INACTIVEнет. Обратите внимание, что столбец с именем пула называется CONNECTION_POOL. В этом примере проверяется, запущен ли пул, и определяется максимальное количество серверов в пуле:

SQL> SELECT connection_pool, status, maxsize FROM dba_cpool_info;

CONNECTION_POOL              STATUS        MAXSIZE
---------------------------- ---------- ----------
SYS_DEFAULT_CONNECTION_POOL  ACTIVE             40
Виды V$PROCESS и V$SESSION

Представление V$SESSION отображает информацию о текущих активных сеансах DRCP. Его также можно объединить с представлением V$PROCESS для корреляции представлений.V$SESSION.PADDR = V$PROCESS.ADDR

V$CPOOL_STATS Просмотр

Представление V$CPOOL_STATS отображает информацию о статистике DRCP для экземпляра. Представление V$CPOOL_STATS можно использовать для оценки эффективности настроек пула. Этот пример запроса показывает, как приложение эффективно использует пул. Низкое количество промахов указывает на повторное использование серверов и сеансов. Счётчик ожидания показывает, что чуть более 1% запросов приходилось ожидать доступности сервера в пуле:

NUM_REQUESTS   NUM_HITS NUM_MISSES  NUM_WAITS
------------ ---------- ---------- ----------
       10031      99990         40       1055
Если cclassустановлено (разрешается повторное использование серверов и сеансов в пуле), то значение NUM_MISSES будет низким. Если максимальный размер пула слишком мал для нагрузки соединений, то значение NUM_WAITS будет высоким.

V$CPOOL_CC_STATS Просмотр

Представление V$CPOOL_CC_STATS отображает информацию о статистике уровня класса соединения для пула по экземплярам:

SQL> select cclass_name, num_requests, num_hits, num_misses
     from v$cpool_cc_stats;

CCLASS_NAME                      NUM_REQUESTS   NUM_HITS NUM_MISSES
-------------------------------- ------------ ---------- ----------
HR.MYCLASS                             100031      99993         38
В столбцах имени класса отображается имя пользователя базы данных, к которому добавлено имя класса подключения.

V$CPOOL_CONN_INFO Просмотр

Представление V$POOL_CONN_INFO предоставляет информацию о клиентских процессах, подключенных к брокеру подключений, что упрощает мониторинг и трассировку приложений, которые в настоящее время используют серверы в пуле или простаивают. Это представление было представлено в Oracle 11gR2.

Вы можете отслеживать представление V$CPOOL_CONN_INFO, например, для выявления неправильно настроенных машин с неправильно заданным классом подключения. Это представление сопоставляет имя машины с именем класса. В режиме Thick python-oracledb имя класса будет задано по умолчанию, как показано ниже:

SQL> select cclass_name, machine from v$cpool_conn_info;

CCLASS_NAME                             MACHINE
--------------------------------------- ------------
CJ.OCI:SP:wshbIFDtb7rgQwMyuYvodA        cjlinux
В этом примере вы проверяете приложения cjlinuxи устанавливаете их cclass.

При подключении к автономной базе данных Oracle Autonomous Database on Shared Infrastructure (ADB-S) представление V$CPOOL_CONN_INFO можно использовать для отслеживания количества успешных и неудачных подключений, чтобы показать эффективность пула.

4.11 Неявный пул соединений
Неявный пул соединений полезен для приложений, создающих избыточную нагрузку на сервер базы данных из-за большого количества открытых отдельных соединений . Если эти приложения невозможно переписать для использования пула соединений python-oracledb , неявный пул соединений может стать одним из вариантов снижения нагрузки на систему базы данных.

Неявный пул соединений позволяет подключениям приложений совместно использовать серверы из пула в DRCP или Oracle Connection Manager в режиме Traffic Director Mode (CMAN-TDM) с резидентным пулом соединений Proxy (PRCP) . Модифицировать приложения не требуется. Эта функция включается добавлением параметра в строку подключенияpool_boundary приложения . Приложениям не требуется явно получать или освобождать соединения для использования пула DRCP или PRCP.

Неявный пул соединений доступен в режимах python-oracledb Thin и Thick . Для него требуется Oracle Database версии 23. Для режима Python-oracledb Thick дополнительно требуются библиотеки Oracle Client версии 23.

При неявном создании пула соединений соединения автоматически извлекаются из пула DRCP или PRCP, когда они фактически используются приложением для работы с базой данных. При неиспользовании они автоматически возвращаются в пул. Это может произойти между явным oracledb.connect()вызовом приложения и Connection.close()(или эквивалентным завершением соединения приложением в конце области действия). Внутреннее завершение соединения может контролироваться значением pool_boundaryпараметра строки соединения, который может быть:

Оператор : Если эта граница указана, то соединение возвращается в пул соединений DRCP или PRCP, если оно неявно не сохраняет состояние. Соединение неявно не сохраняет состояние, когда в нём нет активных курсоров (то есть все строки курсоров были извлечены), нет активных транзакций, нет временных таблиц и нет временных больших объектов (LOB).

transaction : Если эта граница указана, соединение возвращается в пул соединений DRCP или PRCP при вызове одного из методов Connection.commit()или Connection.rollback(). Рекомендуется не устанавливать Connection.autocommit атрибут в значение true при использовании неявного пула соединений. Если этот атрибут установлен, вы не сможете:

Извлечение любых данных, требующих многократного обращения к базе данных.

Выполнять запросы, извлекающие данные LOB и JSON

В соответствии с рекомендациями DRCP и PRCP относительно совместного использования сеансов между различными приложениями следует добавить pool_connection_classпараметр строки подключения, используя одно и то же значение для всех одинаковых приложений.

«Чистота» DRCP и PRCP, используемая в неявном пуле соединений, по умолчанию равна SELF, что позволяет повторно использовать память сеанса серверного процесса для достижения максимальной производительности. Добавление параметра строки подключения pool_purity=newизменит это, и при каждом использовании соединения память сеанса будет пересоздаваться.

Настройка неявного пула соединений

Чтобы использовать неявный пул соединений в python-oracledb с DRCP:

Включите DRCP в базе данных. Например, в SQL*Plus:

SQL> EXECUTE DBMS_CONNECTION_POOL.START_POOL()
Укажите, следует ли использовать объединенный сервер в:

Параметр dsnили oracledb.connect(). oracledb.create_pool()Например, с синтаксисом Easy Connect :

cs = "dbhost.example.com/orclpdb:pooled"

pool = oracledb.create_pool(user="hr", password=userpwd,
                            dsn=cs,
                            min=2, max=5, increment=1,
                            cclass="MYAPP")
Или в дескрипторе подключения, используемом в файле конфигурации Oracle Network, таком как tnsnames.ora , добавив (SERVER=POOLED). Например:

customerpool = (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)
      (HOST=dbhost.example.com)
      (PORT=1521))(CONNECT_DATA=(SERVICE_NAME=CUSTOMER)
      (SERVER=POOLED)))
Или в server_typeпараметре во время или . Например:standalone connection creationconnection pool creation

pool = oracledb.create_pool(user="hr", password=userpwd,
                            host="dbhost.example.com", service_name="orclpdb",
                            min=2, max=5, increment=1, server_type="pooled",
                            cclass="MYAPP")
Установите границу пула для оператора или транзакции в:

Строка Easy Connect . Например, чтобы использовать границу оператора :

dsn = "localhost:1521/orclpdb:pooled?pool_boundary=statement"
Или CONNECT_DATAраздел дескриптора соединения . Например, чтобы использовать границу транзакции :

tnsalias = (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=mymachine.example.com)
            (PORT=1521))(CONNECT_DATA=(SERVICE_NAME=orcl)
            (SERVER=POOLED)(POOL_BOUNDARY=TRANSACTION)))
Или pool_boundaryпараметр в oracledb.connect()или oracledb.create_pool()

Примечание

Неявный пул соединений не включается, если приложение устанавливает pool_boundaryатрибут транзакции или оператора , но не указывает использование сервера пула.

Установите класс соединения в:

Строка Easy Connect . Например, чтобы использовать имя класса «myapp»:

dsn = "localhost:1521/orclpdb:pooled?pool_boundary=statement&pool_connection_class=myapp"
Или CONNECT_DATAраздел дескриптора подключения . Например, чтобы использовать имя класса «myapp»:

tnsalias = (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=mymachine.example.com)
            (PORT=1521))(CONNECT_DATA=(SERVICE_NAME=orcl)
            (SERVER=POOLED)(POOL_BOUNDARY=TRANSACTION)
            (POOL_CONNECTION_CLASS=myapp)))
Используйте одно и то же имя класса соединения для прикладных процессов того же типа, когда вы хотите, чтобы память сеанса повторно использовалась для соединений.

Чистоту пула также можно опционально изменить, добавив ее POOL_PURITY=NEW в строку Easy Connect или в дескриптор подключения.

Аналогичные шаги можно выполнить и с PRCP. Общую информацию о PRCP см. в техническом описании CMAN-TDM — прокси-сервер для подключения к Oracle Database для масштабируемых и высокодоступных приложений .

Неявные заметки о пуле

При использовании неявного пула соединений следует тщательно протестировать приложение, чтобы убедиться, что повторное использование серверов баз данных не приводит к проблемам. Например, любое состояние сеанса, такое как идентификатор сеанса и серийный номер, будет меняться на протяжении всего жизненного цикла соединения приложения, поскольку разные серверы могут использоваться в разное время. Другой пример — использование границы оператора транзакции . В этом случае любая фиксация может сделать открытые курсоры недействительными.

Рекомендуется использовать локальный пул соединений python-oracledb , где это возможно, вместо неявного пула соединений. Это даёт многопользовательским приложениям больше контроля над повторным использованием серверов из пула.

4.12 Привилегированные соединения
Параметр modeфункции oracledb.connect()указывает привилегию базы данных, которую вы хотите связать с пользователем.

В примере ниже показано, как подключиться к Oracle Database как SYSDBA:

connection = oracledb.connect(user="sys", password=syspwd,
                              dsn="dbhost.example.com/orclpdb",
                              mode=oracledb.AuthMode.SYSDBA)  # or mode=oracledb.AUTH_MODE_SYSDBA

with connection.cursor() as cursor:
    cursor.execute("GRANT SYSOPER TO hr")
Это эквивалентно выполнению следующего в SQL*Plus:

CONNECT sys/syspwd@dbhost.example.com/orclpdb AS SYSDBA
GRANT SYSOPER TO hr;
В режиме Thick, когда python-oracledb использует клиентские библиотеки Oracle из установленного программного обеспечения базы данных, вы можете использовать «завещательные» соединения с базами данных, которые также используют те же библиотеки Oracle. Для этого установите стандартные переменные окружения Oracle, такие как ORACLE_HOMEи , ORACLE_SIDи подключитесь в Python следующим образом:

oracledb.init_oracle_client()

conn = oracledb.connect(mode=oracledb.AuthMode.SYSDBA)
Это эквивалентно выполнению следующего в SQL*Plus:

CONNECT / AS SYSDBA
4.13. Безопасное шифрование сетевого трафика в базе данных Oracle
Вы можете зашифровать данные, передаваемые между базой данных Oracle и python-oracledb, чтобы неавторизованные лица не могли просматривать простые текстовые значения при передаче данных по сети.

Оба режима python-oracledb: Thin и Thick — поддерживают TLS. Дополнительную информацию о настройке см. в руководстве по безопасности Oracle Database .

4.13.1 Собственное сетевое шифрование
Режим python-oracledb Thick может дополнительно использовать собственное сетевое шифрование Oracle Database .

При использовании собственного сетевого шифрования клиент и сервер базы данных согласовывают ключ, используя протокол Диффи-Хеллмана. Это обеспечивает защиту от атак типа «человек посередине».

Настроить собственное сетевое шифрование можно, отредактировав дополнительный файл конфигурации Oracle Net sqlnet.ora . Этот файл можно настроить как на сервере базы данных, так и на каждой клиентской машине python-oracledb. Параметры определяют, требуется ли проверка целостности данных и шифрование или только разрешено, а также какие алгоритмы клиент и сервер должны использовать.

Например, чтобы гарантировать проверку целостности и шифрование всех подключений к базе данных, создайте или отредактируйте $ORACLE_HOME/network/admin/sqlnet.oraфайл Oracle Database. Настройте согласование контрольной суммы так, чтобы она всегда проверялась, и выберите нужный тип контрольной суммы. Параметры сетевого шифрования можно настроить аналогичным образом. Например, чтобы использовать контрольную сумму SHA512 и шифрование AES256, выполните следующие действия:

SQLNET.CRYPTO_CHECKSUM_SERVER = required
SQLNET.CRYPTO_CHECKSUM_TYPES_SERVER = (SHA512)
SQLNET.ENCRYPTION_SERVER = required
SQLNET.ENCRYPTION_TYPES_SERVER = (AES256)
Если вы точно знаете, что сервер базы данных обеспечивает целостность и шифрование, вам не нужно настраивать python-oracledb отдельно. Однако вы можете сделать это самостоятельно или в качестве альтернативы, в зависимости от потребностей вашего бизнеса. Создайте sqlnet.oraна клиентской машине файл конфигурации Oracle Net и разместите его вместе с другими дополнительными файлами конфигурации Oracle Net :

SQLNET.CRYPTO_CHECKSUM_CLIENT = required
SQLNET.CRYPTO_CHECKSUM_TYPES_CLIENT = (SHA512)
SQLNET.ENCRYPTION_CLIENT = required
SQLNET.ENCRYPTION_TYPES_CLIENT = (AES256)
Клиентская и серверная стороны могут согласовывать используемые протоколы, если настройки указывают на то, что принимается более одного значения.

Обратите внимание, что это лишь примеры настроек. Вам необходимо изучить требования безопасности и документацию по вашей версии Oracle. В частности, ознакомьтесь с доступными алгоритмами обеспечения безопасности и производительности.

Столбец NETWORK_SERVICE_BANNER представления базы данных V$SESSION_CONNECT_INFO можно использовать для проверки статуса шифрования соединения. Например, с помощью SQL*Plus:

SQL> select network_service_banner from v$session_connect_info;
Если соединение зашифровано, то этот запрос выводит вывод, включающий доступную службу шифрования, службу криптографического контрольного суммирования и используемые алгоритмы, например:

NETWORK_SERVICE_BANNER
-------------------------------------------------------------------------------------
TCP/IP NT Protocol Adapter for Linux: Version 19.0.0.0.0 - Production
Encryption service for Linux: Version 19.0.1.0.0 - Production
AES256 Encryption service adapter for Linux: Version 19.0.1.0.0 - Production
Crypto-checksumming service for Linux: Version 19.0.1.0.0 - Production
SHA256 Crypto-checksumming service adapter for Linux: Version 19.0.1.0.0 - Production
Если соединение не зашифровано, запрос выведет только доступные сервисы шифрования и криптографического контрольного суммирования. Например:

NETWORK_SERVICE_BANNER
-------------------------------------------------------------------------------------
TCP/IP NT Protocol Adapter for Linux: Version 19.0.0.0.0 - Production
Encryption service for Linux: Version 19.0.1.0.0 - Production
Crypto-checksumming service for Linux: Version 19.0.1.0.0 - Production
Дополнительную информацию о шифровании и целостности Oracle Data Network, а также о настройке сетевого шифрования TLS см. в руководстве Oracle AI Database Security Guide .

4.14. Сброс паролей
После подключения к Oracle Database пароли можно изменить, вызвав Connection.changepassword():

# Get the passwords from somewhere, such as prompting the user
oldpwd = getpass.getpass(f"Old Password for {username}: ")
newpwd = getpass.getpass(f"New Password for {username}: ")

connection.changepassword(oldpwd, newpwd)
Если срок действия пароля истек и вы не можете подключиться напрямую, вы можете подключиться и изменить пароль за одну операцию, используя параметр конструктора newpasswordфункции oracledb.connect():

# Get the passwords from somewhere, such as prompting the user
oldpwd = getpass.getpass(f"Old Password for {username}: ")
newpwd = getpass.getpass(f"New Password for {username}: ")

connection = oracledb.connect(user=username, password=oldpwd,
                              dsn="dbhost.example.com/orclpdb",
                              newpassword=newpwd)
4.15 Подключение к автономным базам данных Oracle Cloud
Приложения Python могут подключаться к автономной базе данных Oracle Autonomous Database (ADB) в Oracle Cloud с использованием одностороннего протокола TLS (Transport Layer Security) или взаимного протокола TLS (mTLS), в зависимости от конфигурации экземпляра базы данных. Односторонний TLS и mTLS обеспечивают повышенную безопасность аутентификации и шифрования.

Для подключения к приложению по-прежнему требуются имя пользователя и пароль базы данных. См. соответствующую документацию по Oracle Cloud, например, раздел « Создание пользователей базы данных» .

4.15.1 Одностороннее TLS-подключение к автономной базе данных Oracle
При использовании одностороннего TLS хост-компьютер python-oracledb должен быть в списке контроля доступа (ACL) экземпляра ADB. Приложения подключаются к Oracle ADB, передавая имя пользователя базы данных, пароль и соответствующую строку подключения. Кошелек не используется.

Оба режима python-oracledb: Thin и Thick — поддерживают односторонний TLS.

4.15.1.1. Разрешение одностороннего TLS-доступа к автономной базе данных Oracle
Чтобы создать экземпляр ADB, поддерживающий односторонний TLS, выберите параметр доступа «Безопасный доступ только с разрешённых IP-адресов и сетей виртуальных сетей» в консоли Oracle Cloud во время создания экземпляра. Затем укажите IP-адреса, имена хостов, блоки CIDR, сети виртуальных облаков (VCN) или идентификаторы OCID сетей виртуальных облаков, где будет работать Python. Список контроля доступа (ACL) ограничивает доступ только к определённым ресурсам и блокирует весь остальной входящий трафик.

В качестве альтернативы, чтобы включить односторонний TLS в существующей базе данных, выполните следующие шаги в консоли Oracle Cloud в разделе «Информация об автономной базе данных» экземпляра ADB:

Нажмите ссылку «Изменить» рядом со списком контроля доступа , чтобы обновить список контроля доступа (ACL).

В открывшемся диалоговом окне «Изменить список контроля доступа» выберите тип записей списка адресов и соответствующие значения. Вы можете включить IP-адреса, имена хостов, блоки CIDR, сети виртуальных облаков (VCN) или идентификаторы OCID сетей виртуальных облаков, где будет работать Python.

Вернитесь на страницу сведений об экземпляре ADB и нажмите ссылку «Изменить» рядом с пунктом «Взаимная аутентификация TLS (mTLS)» .

В отобразившемся диалоговом окне «Изменить взаимную аутентификацию TLS» снимите флажок «Требовать взаимную аутентификацию TLS (mTLS)» , чтобы отключить требование mTLS в Oracle ADB, и нажмите кнопку «Сохранить изменения» .

4.15.1.2. Подключение к тонкому или толстому режимам python-oracledb с использованием одностороннего TLS
Когда в вашей базе данных включено разрешение на одностороннее соединение TLS, вы можете подключиться к python-oracledb, выполнив следующие действия:

Перейдите на страницу сведений об экземпляре ADB на консоли Cloud и нажмите «Подключение к базе данных» в верхней части страницы.

В открывшемся диалоговом окне «Подключение к базе данных» выберите TLS в раскрывающемся списке « Строки подключения» .

Скопируйте соответствующую строку подключения для нужного вам уровня обслуживания подключения.

Приложения могут подключаться, используя учётные данные базы данных и скопированную строку подключения . Не передавайте параметры кошелька. Например, чтобы подключиться как пользователь ADMIN:

cs = '''(description= (retry_count=20)(retry_delay=3)(address=(protocol=tcps)(port=1521)
        (host=adb.abcdef.oraclecloud.com))
        (connect_data=(service_name=abcde_mydb_high.adb.oraclecloud.com))
        (security=(ssl_server_dn_match=yes)))'''

connection = oracledb.connect(user="admin", password=pw, dsn=cs)
Если вы предпочитаете хранить дескрипторы соединений вне кода приложения, вы можете добавить дескриптор с псевдонимом TNS в файл tnsnames.ora и использовать псевдоним TNS в качестве dsnзначения.

Неправильная настройка ACL является частой причиной ошибок подключения. Для облегчения устранения неполадок удалите его (retry_count=20)(retry_delay=3)из дескриптора подключения, чтобы ошибки возвращались быстрее. Если есть подозрения на проблемы с конфигурацией сети, для первоначального устранения неполадок с одноразовой базой данных можно обновить ACL, включив в него блок CIDR 0.0.0.0/0. Однако это означает, что любой может попытаться подключиться к вашей базе данных, поэтому следует пересоздать базу данных сразу после определения работающего, более строгого ACL.

Для подключения в режиме Thick python-oracledb требуется клиентская библиотека Oracle версии 19.14 (или более поздней), 21.5 (или более поздней) или 23.3 (или более поздней). Если вы экспериментировали с mTLS и в вашей среде настроены файлы sqlnet.oramTLS tnsnames.ora, удалите их перед использованием режима Thick python-oracledb с односторонним TLS, чтобы избежать конфликтов конфигураций.

4.15.2. Подключение по протоколу Mutual TLS (mTLS) к автономной базе данных Oracle
Чтобы включить подключения python-oracledb к автономной базе данных Oracle в Oracle Cloud с использованием mTLS, необходимо загрузить кошелек из облачной консоли. mTLS иногда называют двусторонним TLS.

4.15.2.1. Разрешение доступа mTLS к автономной базе данных Oracle
При создании экземпляра ADB в консоли Oracle Cloud выберите настройку доступа «Безопасный доступ из любого места».

4.15.2.2 Загрузка базы данных кошелька
После того как ваша автономная база данных будет активирована для поддержки mTLS, загрузите ее wallet.zipфайл, содержащий файлы сертификата и конфигурации сети:

Перейдите на страницу сведений об экземпляре ADB на консоли Oracle Cloud и нажмите «Подключение к базе данных» в верхней части страницы.

В открывшемся диалоговом окне «Подключение к базе данных» нажмите кнопку «Загрузить кошелёк» в разделе « Загрузить учётные данные клиента (Кошелёк)» . Облачная консоль предложит вам создать пароль к кошельку. Этот пароль требуется python-oracledb в тонком режиме, но не используется в толстом режиме.

Примечание : Храните файлы кошелька в безопасном месте и сообщайте их и пароль только авторизованным пользователям.

4.15.2.3. Подключение к тонкому режиму python-oracledb с использованием mTLS
Для тонкого режима python-oracledb распакуйте файл wallet.zip . Из него понадобятся только два файла:

tnsnames.ora- Сопоставляет псевдонимы TNS, используемые для строк подключения приложений со службами вашей базы данных.

ewallet.pem- Включает SSL/TLS-соединения в тонком режиме. Сохраните этот файл в безопасности.

Если у вас нет PEM-файла, см. раздел Создание PEM-файла для тонкого режима python-oracledb .

Переместите оба файла в каталог, доступный вашему приложению. В этом примере файлы находятся в одном каталоге, /opt/OracleCloud/MYDB.

Подключение можно установить, используя учетные данные вашей базы данных и установив в качестве dsnпараметра нужный псевдоним TNS из файла tnsnames.ora . Этот config_dirпараметр указывает на каталог, содержащий файл tnsnames.ora . Этот wallet_locationпараметр — каталог, содержащий PEM-файл. В wallet_passwordкачестве параметра следует указать пароль, созданный в облачной консоли при загрузке кошелька. Это не пароль пользователя базы данных или администратора. Например, чтобы подключиться как пользователь ADMIN с использованием mydb_lowпсевдонима TNS:

connection = oracledb.connect(
    user="admin",
    password=pw,                               # database password for ADMIN
    dsn="mydb_low",                            # TNS Alias from tnsnames.ora
    config_dir="/opt/OracleCloud/MYDB",        # directory with tnsnames.ora
    wallet_location="/opt/OracleCloud/MYDB",   # directory with ewallet.pem
    wallet_password=wp                         # not a database user password
)
4.15.2.4. Подключение к python-oracledb в режиме Thick с использованием mTLS
Для режима python-oracledb Thick распакуйте файл wallet.zip . Из него понадобятся только три файла:

tnsnames.ora- Сопоставляет псевдонимы TNS, используемые для строк подключения приложений со службами вашей базы данных.

sqlnet.ora- Настраивает параметры сети Oracle

cwallet.sso- Включает SSL/TLS-соединения в режиме python-oracledb Thick. Сохраните этот файл в безопасности.

Существует два варианта размещения необходимых файлов:

Переместите три файла в network/adminкаталог клиентских библиотек, используемых вашим приложением. Например, если вы используете Oracle Instant Client версии 23 в каталоге $HOME/instantclient_23_9, то файлы кошелька следует поместить в каталог $HOME/instantclient_23_9/network/admin/.

Подключение можно установить, используя учетные данные вашей базы данных и указав в качестве dsnпараметра нужный псевдоним TNS из файла tnsnames.ora . Например, чтобы подключиться как пользователь ADMIN с mydb_lowпсевдонимом TNS:

connection = oracledb.connect(user="admin", password=pw, dsn="mydb_low")
Либо переместите три файла в любой доступный каталог, например /opt/OracleCloud/MYDB.

Затем отредактируйте sqlnet.oraи измените каталог расположения кошелька на каталог, содержащий cwallet.ssoфайл. Например:

WALLET_LOCATION = (SOURCE = (METHOD = file) (METHOD_DATA = (DIRECTORY="/opt/OracleCloud/MYDB")))
SSL_SERVER_DN_MATCH=yes
Поскольку файлы tnsnames.oraи sqlnet.oraнаходятся не в каталоге по умолчанию, ваше приложение должно указать их местоположение либо с помощью config_dirпараметра to oracledb.init_oracle_client(), либо с помощью TNS_ADMINпеременной окружения. См. раздел Необязательные файлы конфигурации Oracle Net . (Ни один из этих параметров не требуется, и вам не нужно редактировать sqlnet.ora, если вы поместили все файлы в network/adminкаталог.)

Например, чтобы подключиться как пользователь ADMIN, используя mydb_lowпсевдоним TNS:

oracledb.init_oracle_client(config_dir="/opt/OracleCloud/MYDB")

connection = oracledb.connect(user="admin", password=pw, dsn="mydb_low")
В режиме Python-Oracle Thick для создания mTLS-подключений к двум или более автономным базам данных Oracle в одном процессе Python необходимо переместить каждый cwallet.ssoфайл в отдельный каталог. Для каждого подключения используйте разные WALLET_LOCATIONпараметры строки подключения, чтобы указать каталог каждого файла. При использовании нескольких кошельковcwallet.sso рекомендуется использовать клиентские библиотеки Oracle версии 19.17 (или более поздней) .

Если вы находитесь за брандмауэром, см. раздел Подключение через брандмауэр через прокси-сервер .

4.15.2.5 Использование синтаксиса Easy Connect с автономной базой данных Oracle
Если python-oracledb использует клиентские библиотеки Oracle версии 19c или более поздней, вы можете дополнительно использовать синтаксис Easy Connect для подключения к автономной базе данных Oracle.

В этом разделе обсуждаются параметры подключения mTLS.

Сопоставление записей облачного файла tnsnames.ora со строкой Easy Connect выглядит следующим образом:

protocol://host:port/service_name?wallet_location=/my/dir&retry_count=N&retry_delay=N
Например, если в вашем tnsnames.oraфайле есть запись:

cjjson_high = (description=(retry_count=20)(retry_delay=3)
    (address=(protocol=tcps)(port=1522)
    (host=xxx.oraclecloud.com))
    (connect_data=(service_name=abc_cjjson_high.adb.oraclecloud.com))
    (security=(ssl_server_cert_dn="CN=xxx.oraclecloud.com,O=Oracle Corporation,L=Redwood City,ST=California,C=US")))
Затем ваши приложения смогут подключаться, используя строку подключения:

dsn = "tcps://xxx.oraclecloud.com:1522/abc_cjjson_high.adb.oraclecloud.com?wallet_location=/Users/cjones/Cloud/CJJSON&retry_count=20&retry_delay=3"
connection = oracledb.connect(user="hr", password=userpwd, dsn=dsn)
Параметр wallet_locationнеобходимо указать на каталог, содержащий файл wallet.zip cwallet.sso, или ewallet.pemфайл, извлечённый из архива wallet.zip . Остальные файлы, включая tnsnames.ora, не требуются при использовании синтаксиса Easy Connect.

Вы можете добавить в строку подключения другие параметры Easy Connect, например:

dsn = dsn + "&https_proxy=myproxy.example.com&https_proxy_port=80"
В тонком режиме python-oracledb пароль кошелька необходимо передавать как параметр соединения.

4.15.2.6 Создание PEM-файла для тонкого режима python-oracledb
Для Mutual TLS в тонком режиме python-oracledb сертификат должен быть в формате Privacy Enhanced Mail (PEM). Если вы используете Oracle Autonomous Database, ZIP-файл вашего кошелька уже будет содержать PEM-файл.

Если у вас есть ewallet.p12файл PKCS12 и вам нужно создать PEM-файл, вы можете использовать сторонние инструменты или скрипт ниже для конвертации. Например, вы можете вызвать скрипт, передав пароль кошелька и каталог, содержащий файл PKCS12:

python create_pem.py --wallet-password 'xxxxx' /Users/scott/cloud_configs/MYDBDIR
После создания PEM-файла его можно использовать, передав местоположение его каталога в качестве wallet_locationпараметра методу oracledb.connect()или oracledb.create_pool(). Эти методы также принимают wallet_passwordпараметр. См. раздел «Mutual TLS (mTLS) Connection to Oracle Autonomous Database» (Подключение по протоколу Mutual TLS (mTLS) к автономной базе данных Oracle) .

Скрипт для конвертации из PKCS12 в PEM

# create_pem.py

import argparse
import getpass
import os

from cryptography.hazmat.primitives.serialization \
        import pkcs12, Encoding, PrivateFormat, BestAvailableEncryption, \
               NoEncryption

# parse command line
parser = argparse.ArgumentParser(description="convert PKCS#12 to PEM")
parser.add_argument("wallet_location",
                    help="the directory in which the PKCS#12 encoded "
                         "wallet file ewallet.p12 is found")
parser.add_argument("--wallet-password",
                    help="the password for the wallet which is used to "
                         "decrypt the PKCS#12 encoded wallet file; if not "
                         "specified, it will be requested securely")
parser.add_argument("--no-encrypt",
                    dest="encrypt", action="store_false", default=True,
                    help="do not encrypt the converted PEM file with the "
                         "wallet password")
args = parser.parse_args()

# validate arguments and acquire password if one was not specified
pkcs12_file_name = os.path.join(args.wallet_location, "ewallet.p12")
if not os.path.exists(pkcs12_file_name):
    msg = f"wallet location {args.wallet_location} does not contain " \
           "ewallet.p12"
    raise Exception(msg)
if args.wallet_password is None:
    args.wallet_password = getpass.getpass()

pem_file_name = os.path.join(args.wallet_location, "ewallet.pem")
pkcs12_data = open(pkcs12_file_name, "rb").read()
result = pkcs12.load_key_and_certificates(pkcs12_data,
                                          args.wallet_password.encode())
private_key, certificate, additional_certificates = result
if args.encrypt:
    encryptor = BestAvailableEncryption(args.wallet_password.encode())
else:
    encryptor = NoEncryption()
with open(pem_file_name, "wb") as f:
    f.write(private_key.private_bytes(Encoding.PEM, PrivateFormat.PKCS8,
                                      encryptor))
    f.write(certificate.public_bytes(Encoding.PEM))
    for cert in additional_certificates:
        f.write(cert.public_bytes(Encoding.PEM))
print("PEM file", pem_file_name, "written.")
4.16 Подключение через брандмауэр через прокси-сервер
Если вы находитесь за брандмауэром, вы можете туннелировать соединения TLS/SSL через прокси-сервер, настроив атрибуты соединения или указав имя прокси-сервера HTTPS_PROXY и параметры порта HTTPS_PROXY_PORT в строке подключения .

Примечание

Oracle не рекомендует подключаться через брандмауэр через прокси-сервер, когда производительность имеет решающее значение.

В тонком режиме python-oracledb

Настройки прокси-сервера https_proxyможно https_proxy_portпередать при подключении или создании пула. Используйте соответствующие значения для вашего прокси-сервера:

connection = oracledb.connect(user="admin", password=pw, dsn="mydb_low",
                              config_dir="/opt/OracleCloud/MYDB",
                              wallet_location="/opt/OracleCloud/MYDB", wallet_password=wp,
                              https_proxy="myproxy.example.com", https_proxy_port=80)
В качестве альтернативы добавьте параметры в строку Easy Connect :

localhost/orclpdb&https_proxy=myproxy.example.com&https_proxy_port=80
Альтернативный вариант — обновить дескриптор подключения (передаваемый непосредственно во время подключения или содержащийся в файле tnsnames.ora ). Если вы используете файл tnsnames.ora , изменённая запись может выглядеть так:

mydb_low = (description=
             (address=
               (https_proxy=myproxy.example.com)(https_proxy_port=80)
               (protocol=tcps)(port=1522)(host= . . . )
В толстом режиме python-oracledb

Если вы используете строку Easy Connect , добавьте параметры HTTPS_PROXYи HTTPS_PROXY_PORTсоответствующие значения для вашего прокси-сервера. Например, вы можете передать такие параметры:

localhost/orclpdb&https_proxy=myproxy.example.com&https_proxy_port=80
Альтернативный вариант — обновить дескриптор подключения (передаваемый непосредственно во время подключения или содержащийся в файле tnsnames.ora ). Если вы используете файл tnsnames.ora , изменённая запись может выглядеть так:

mydb_low = (description=
             (address=
               (https_proxy=myproxy.example.com)(https_proxy_port=80)
               (protocol=tcps)(port=1522)(host= . . . )
Дополнительно создайте или отредактируйте файл sqlnet.ora и добавьте строку:

SQLNET.USE_HTTPS_PROXY=on
4.17. Подключение с использованием нескольких кошельков
Вы можете создать несколько соединений с разными кошельками в одном процессе Python.

В тонком режиме python-oracledb

Чтобы использовать несколько кошельков в тонком режиме python-oracledb, передайте различные строки подключения, местоположения кошелька и пароль кошелька (при необходимости) в каждом oracledb.connect()вызове или при создании пула подключений :

connection = oracledb.connect(user=user_name, password=userpw, dsn=dsn,
                              config_dir="path_to_unzipped_wallet",
                              wallet_location="location_of_pem_file",
                              wallet_password=walletpw)
Параметр config_dir— это каталог, содержащий файл tnsnames.ora . wallet_locationПараметр — это каталог, содержащий ewallet.pemфайл. Если вы используете автономную базу данных Oracle, оба этих пути обычно указывают на тот же каталог, куда был распакован файл wallet.zipdsn . Следует указать TCPS-подключение.

В толстом режиме python-oracledb

MY_WALLET_DIRECTORYЧтобы использовать несколько кошельков в режиме python-oracledb Thick, необходимо создать строку подключения TCPS, содержащую следующую опцию:

dsn = "mydb_high"   # one of the TNS Aliases from tnsnames.ora
params = oracledb.ConnectParams(config_dir="path_to_unzipped_wallet",
                                wallet_location="path_location_of_sso_file")
params.parse_connect_string(dsn)
dsn = params.get_connect_string()
connection = oracledb.connect(user=user_name, password=password, dsn=dsn)
Параметр config_dirдолжен указывать на каталог, содержащий файл tnsnames.ora и sqlnet.oraфайлы. wallet_locationПараметр указывает на каталог, содержащий cwallet.sso файл. Если вы используете автономную базу данных Oracle, оба этих пути обычно указывают на тот же каталог, куда был распакован файл wallet.zip .

Примечание

Используйте библиотеки Oracle Client версии 19.17 или более поздней, либо Oracle Client версии 21 или 23. Они содержат важные исправления ошибок, связанных с использованием нескольких кошельков в одном процессе.

4.18 Подключение к глобально распределенной базе данных Oracle
Oracle Globally Distributed Database — это функция Oracle Database, которая позволяет автоматически распределять и реплицировать данные в пуле баз данных Oracle, не использующих общее аппаратное или программное обеспечение. Ранее эта функция была известна как Oracle Sharding. Она позволяет разделить таблицу базы данных таким образом, чтобы каждая база данных содержала таблицу с одинаковыми столбцами, но разным подмножеством строк. Такие таблицы называются шардированными таблицами. С точки зрения приложения шардированная таблица в Oracle Globally Distributed AI Database выглядит как одна таблица: распределение данных по этим шардам полностью прозрачно для приложения.

Шардинг настраивается в Oracle Database, см. руководство Oracle Globally Distributed AI Database . Для него требуются Oracle Database и клиентские библиотеки Oracle версии 12.2 или более поздней.

Примечание

Oracle Globally Distributed Database поддерживается только в режиме python-oracledb Thick. См. раздел Включение режима python-oracledb Thick .

Функции oracledb.connect()и ConnectionPool.acquire()принимают параметры shardingkeyи supershardingkey, представляющие собой последовательность значений, используемых для маршрутизации соединения непосредственно к заданному шарду. Ключ шардирования требуется всегда. Ключ супершардирования также требуется при использовании составного шардирования, когда данные были разделены по списку или диапазону (ключ супершардирования), а затем дополнительно разделены по ключу шардирования.

oracledb.create_pool()Этот атрибут можно задать при создании пула подключений max_sessions_per_shard. Он используется для равномерной балансировки подключений в пуле между шардами. Для этого требуются клиентские библиотеки Oracle версии 18.3 или более поздней.

Значения ключей шарда могут быть строковыми (соответствующими ключам шарда VARCHAR2), числовыми (NUMBER), байтовыми (RAW) или датами (DATE). В каждом массиве могут использоваться несколько типов. Ключи шарда типа TIMESTAMP не поддерживаются.

При подключении к шарду запросы будут возвращать данные только из этого шарда. Для запросов, которым требуется доступ к данным из нескольких шардов, можно установить подключение к базе данных каталога шардов-координаторов. В этом случае ключ шарда или суперключ шарда не используются.

В качестве примера прямого подключения, если бы шардинг был настроен на одном столбце VARCHAR2, например:

CREATE SHARDED TABLE customers (
  cust_id NUMBER,
  cust_name VARCHAR2(30),
  class VARCHAR2(10) NOT NULL,
  signup_date DATE,
  cust_code RAW(20),
  CONSTRAINT cust_name_pk PRIMARY KEY(cust_name))
  PARTITION BY CONSISTENT HASH (cust_name)
  PARTITIONS AUTO TABLESPACE SET ts1;
то прямое подключение к шарду можно осуществить, передав один ключ шардинга:

connection = oracledb.connect(user="hr", password=userpwd,
                              dsn="dbhost.example.com/orclpdb",
                              shardingkey=["SCOTT"])
Аналогичным образом можно использовать цифровые клавиши:

connection = oracledb.connect(user="hr", password=userpwd,
                              dsn="dbhost.example.com/orclpdb",
                              shardingkey=[110])
При шардинге по ДАТЕ можно подключиться следующим образом:

import datetime

d = datetime.datetime(2014, 7, 3)

connection = oracledb.connect(user="hr", password=userpwd,
                              dsn="dbhost.example.com/orclpdb",
                              shardingkey=[d])
При шардинге по RAW можно подключиться так:

b = b'\x01\x04\x08';

connection = oracledb.connect(user="hr", password=userpwd,
                              dsn="dbhost.example.com/orclpdb",
                              shardingkey=[b])
Можно указать несколько ключей, например:

key_list = [70, "SCOTT", "gold", b'\x00\x01\x02']

connection = oracledb.connect(user="hr", password=userpwd,
                              dsn="dbhost.example.com/orclpdb",
                              shardingkey=key_list)
Пример ключа супершардинга:

connection = oracledb.connect(user="hr", password=userpwd,
                              dsn="dbhost.example.com/orclpdb",
                              supershardingkey=["goldclass"],
                              shardingkey=["SCOTT"])
