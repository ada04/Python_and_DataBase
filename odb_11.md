# under construction

# 11. Настройка python-oracledb

Вот несколько общих советов по настройке:

- Настройте архитектуру вашего приложения.

  Общая цель приложения — сократить количество обращений между python-oracledb и базой данных.

  Для многопользовательских приложений используйте пул соединений. Создайте пул один раз при инициализации приложения. Не превышайте размер пула (см. [раздел «Пул соединений»](odb_04.md#4_9)). Используйте функцию обратного вызова сеанса для установки состояния сеанса (см. [раздел «Обратные вызовы сеанса для установки состояния пула соединений»](odb_04.md#4_9_6)) .

  Используйте эффективные функции python-oracledb. Например, для вставки нескольких строк используйте `Cursor.executemany()` вместо `Cursor.execute()`. В качестве альтернативы, для вставки очень больших наборов данных используйте `Connection.direct_path_load()`. Другой пример — извлечение данных непосредственно в виде фреймов данных вместо использования традиционного кода запроса при работе с такими пакетами, как Pandas и NumPy.

- Настройте SQL-запросы. См. [Руководство по настройке SQL](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=TGSQL).

  Используйте переменные связывания , чтобы избежать повторного анализа операторов.

  Настройте  `Cursor.arraysize` и `Cursor.prefetchrows` для каждого запроса SELECT см. [раздел Настройка производительности выборки](odb_11.md#11_1) .

  Выполните простые оптимизации, например [ограничьте количество строк](odb_06.md#6_1_9) и избегайте выбора столбцов, не используемых в приложении.

  Работать с простыми скалярными реляционными значениями может быть быстрее, чем использовать типы объектов Oracle Database.

  Эффективно используйте PL/SQL, чтобы избежать выполнения множества отдельных операторов из python-oracledb.

  Настройте [кэш операторов](odb_11.md#11_3).

  Для небольших таблиц включите [кэширование результатов](odb_11.md#11_4).

- Настройте свою базу данных. См. [Руководство по настройке производительности базы данных](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=TGDBA).

- Настройте сеть. Например, при вставке или извлечении большого количества строк (или больших объёмов данных) или при использовании медленной сети настройте размер блока [данных сеанса Oracle Network (SDU)](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-86D61D6F-AD26-421A-BABA-77949C8A2B04) и буфера сокета. См. [разделы «Настройка блока данных сеанса» и «Oracle Net Services: лучшие практики обеспечения производительности и высокой доступности баз данных»](https://static.rainfocus.com/oracle/oow19/sess/1553616880266001WLIh/PF/OOW19_Net_CON4641_1569022126580001esUl.pdf) .

  В режиме Thick python-oracledb размер SDU настраивается в дополнительных файлах [конфигурации Oracle Net](odb_03.md#3_3_1). В режиме Thin python-oracledb размер SDU может быть передан как параметр создания соединения или пула. В обоих режимах его можно дополнительно задать в строке [Easy Connect](odb_04.md#4_2_1) соединения или в [дескрипторе соединения](odb_04.md#4_2_2). Фактически используемый размер SDU определяется по наименьшему из двух значений: значения на стороне приложения и значения конфигурации SDU сети базы данных.

  Не фиксируйте и не откатывайте транзакции без необходимости. Используйте `Connection.autocommit` в конце последовательности операторов DML.

  Рассмотрите возможность использования [параллельного программирования](odb_23.md#23_1) или [конвейеризации](odb_23.md#23_2).

  Если глобальная блокировка интерпретатора (GIL) Python ограничивает производительность параллельных программ, то рассмотрите возможность использования параллельных процессов Python.

## 11.1. Настройка производительности выборки

Для повышения производительности и масштабируемости приложения можно настроить внутренние буферы python-oracledb `Cursor.prefetchrows` и `Cursor.arraysize`, используемые для результатов запросов SELECT и REF CURSOR. Увеличение размеров приводит к выборке большего количества строк при каждом внутреннем запросе к базе данных. Это сокращает количество необходимых [циклов передачи данных](odb_11.md#11_2). Выигрыш в производительности от увеличения размера буфера может быть значительным при выборке большого количества строк или при использовании медленного сетевого соединения. База данных также выигрывает от снижения накладных расходов.

Внутренне python-oracledb всегда выполняет предварительную выборку строк и выборку массивов. Предварительная выборка строк происходит, когда строки возвращаются из базы данных в цикле, используемом для выполнения начального оператора. После этого строки доступны во внутреннем буфере для использования приложением. Без предварительной выборки первый набор строк пришлось бы извлекать из базы данных с помощью отдельного цикла. Когда все строки в буфере предварительной выборки будут использованы приложением, следующий набор строк извлекается в буфер с помощью выборки массива, которая занимает один цикл. Эти строки становятся доступны приложению по мере необходимости. После того, как начальный буфер выборки массива опустошается, дальнейшие выборки массива в буфер происходят по мере необходимости для полного извлечения всех строк из базы данных.

Изменение размеров буфера с помощью `prefetchrows` и `arraysize` влияет на внутреннее поведение буферизации `Cursor.fetchone()`, `Cursor.fetchmany()` и `Cursor.fetchall()`. Значения атрибутов не влияют на то, как строки возвращаются в приложение, за исключением `Cursor.fetchmany()`, где `Cursor.arraysize` также используется в качестве значения по умолчанию для его `size` параметра.

Накладные расходы на предварительную выборку строк в режиме Thick в Python-Oracledb заключаются в использовании отдельного буфера, отличного от буфера выборки массива, что увеличивает требования к памяти. Кроме того, выполняется дополнительное копирование данных из буфера предварительной выборки клиента Oracle. В некоторых случаях эти затраты могут перевесить преимущества использования предварительной выборки.

> Запросы SELECT, возвращающие объекты LOB и подобные типы, никогда не будут предварительно выбирать строки, поэтому `prefetchrows` в этих случаях значение игнорируется.

Атрибуты не влияют на вставку данных. Чтобы сократить количество циклов выполнения операторов DML, см. [раздел Пакетные операторы и операции массового копирования](odb_09.md).

### 11.1.1 Выбор значений для `arraysize` и `prefetchrows`

Настройте «выборку массива» с помощью `Cursor.arraysize`. Настройте «предварительную выборку строк» ​​с помощью `Cursor.prefetchrows`. Установите эти значения перед вызовом `Cursor.execute()`. См. также [Application Default Prefetchrows and Arraysize Values](odb_11.md#11_1_1_1).

Оптимальные значения для `arraysize` и `prefetchrows` можно определить, проведя сравнительный анализ производительности приложения под нагрузкой. Вот начальные рекомендации для четырёх распространённых сценариев:

- Сценарий 1: Чтобы оптимизировать запросы, возвращающие неизвестное и большое количество строк, увеличивайте значение `arraysize` по умолчанию равный `100` до тех пор, пока не будете удовлетворены производительностью, объёмом памяти и использованием циклов передачи данных. Например:

  ```
  cursor = connection.cursor()
  
  # cursor.prefetchrows = 2  # generally leave this at its default
  cursor.arraysize = 1000

  for row in cursor.execute("select * from very_big_table"):
      print(row)
  ```

  В этом случае, как правило, оставляйте `prefetchrows` значение по умолчанию. Если вы всё же решите изменить его, установите для `Cursor.arraysize` большее значение. Не делайте размеры слишком большими без необходимости.

- Сценарий 2: Если вы извлекаете фиксированное количество строк, установите значение `arraysize`, равное ожидаемому количеству строк, и значение `prefetchrows`, на единицу больше этого значения. Добавление единицы устраняет необходимость в циклическом запросе для проверки конца выборки. Например, если вы используете запрос SELECT для пагинации по 20 строк, установите значения `prefetchrows` `21` и `arraysize` `20`:

  ```
  cursor = connection.cursor()

  cursor.prefetchrows = 21
  cursor.arraysize = 20

  for row in cursor.execute("""
      select last_name
         from employees
         order by last_name
         offset 0 rows fetch next 20 rows only"""):
      print(row)
  ``
  
  Это вернет все строки запроса за один цикл.

- Сценарий 3: Если количество строк, возвращаемых оператором SELECT в вашем приложении, варьируется от выполнения к выполнению, но никогда не бывает большим, вы можете использовать стратегию, аналогичную сценарию 2.

  Выберите значения `arraysize` и `prefetchrows`, которые хорошо подходят для ожидаемого максимального количества строк.

- Сценарий 4: Если вы знаете, что запрос SELECT возвращает только одну строку, установите значение `arraysize` `1`, чтобы минимизировать использование памяти. Значение `prefetch` по умолчанию, равное 2, обеспечивает минимальное количество циклов обработки для однострочных запросов:

  ```
  cursor = connection.cursor()

  cursor.arraysize = 1

  cursor.execute("select * from MyTable where id = 1"):
  row = cursor.fetchone()
  print(row)
  ```

##### Ньюансы при использовании циклических запросов для получения данных.

В следующей таблице показано количество циклов, необходимых для выборки различного количества строк с разными значениями `prefetchrows` и `arraysize`.

*Таблица 11.1 Влияние количества поездок prefetchrowsтуда и обратно на их количествоarraysize*

|Количество строк|`prefetchrows`|`arraysize`|Round-trips|
|-|-|-|-|
|1|2|100|1|
|100|2|100|2|
|1000|2|100|11|
|10000|2|100|101|
|10000|2|1000|11|
|10000|1000|1000|11|
|20|20|20|2|
|20|21|20|1|

Количество циклов будет одинаковым независимо от того, какой метод python-oracledb используется для получения результатов запроса.

#### 11.1.1.1. Установка в приложении значений по умолчанию для `prefetchrows` и `Arraysize`

Настройки по умолчанию для всего приложения можно задать с помощью `oracledb.defaults.prefetchrows` и `oracledb.defaults.arraysize`, например:

```
import oracledb

oracledb.defaults.prefetchrows = 1000
oracledb.defaults.arraysize    = 1000
```

При использовании python-oracledb в режиме Thick предварительную выборку также можно настроить во внешнем файле [oraaccess.xml](odb_03.md#3_3_2), что может быть полезно для настройки приложения, когда изменение его кода невозможно.

Настройка размеров с помощью атрибутов `oracledb.defaults` или с помощью `oraaccess.xml` повлияет на все приложение, поэтому старайтесь избегать использования этих настроек.

#### 11.1.1.2. Изменение `prefetchrows` и `Arraysize` для повторно выполняемых операторов

В python-oracledb значения `prefetchrows` и `arraysize` проверяются только при первом выполнении оператора. Чтобы изменить значения для повторно выполняемого оператора, создайте новый курсор. Например, чтобы изменить `arraysize`:

```
array_sizes = (10, 100, 1000)
for size in array_sizes:
    cursor = connection.cursor()
    cursor.arraysize = size
    start = time.time()
    cursor.execute(sql).fetchall()
    elapsed = time.time() - start
    print("Time for", size, elapsed, "seconds")
```

#### 11.1.1.3. Предотвращение преждевременной предварительной загрузки

Есть два случая, когда полезно установить значение `prefetchrows` равным нулю:

- При передаче курсора python-oracledb в PL/SQL. Установка значения `prefetchrows` = `0` может предотвратить преждевременную (и скрытую) загрузку строк во внутренний буфер python-oracledb, делая эти строки недоступными для PL/SQL параметра REF CURSOR:

  ```
  refcursor = connection.cursor()
  refcursor.prefetchrows = 0
  refcursor.execute("select ...")
  cursor.callproc("myproc", [refcursor])
  ```

- При запросе функции PL/SQL, которая использует PIPE ROW для периодической выдачи строк. По умолчанию функция должна выдать несколько строк, прежде чем python-oracledb сможет вернуть их приложению. Установка значения `prefetchrows` = `0` обеспечивает равномерную передачу данных в приложение.

### 11.1.2. Настройка выборки из REF CURSORS

Внутреннюю буферизацию и производительность выборки данных из REF CURSORS можно настроить, установив значение `arraysize` до выборки строк из курсора. При выборке из REF CURSORS **значение** `prefetchrows` **игнорируется**.

Например:

```
ref_cursor = connection.cursor()
cursor.callproc("myrefcursorproc", [ref_cursor])

ref_cursor.arraysize = 1000
print("Sum of IntCol for", num_rows, "rows:")
for row in ref_cursor:
    sum_rows += row[0]
print(sum_rows)
```

Значение `Cursor.arraysize` также можно установить перед вызовом процедуры:

```
ref_cursor = connection.cursor()
ref_cursor.arraysize = 1000

cursor.callproc("myrefcursorproc", [ref_cursor])
for row in ref_cursor:
    . . .
```

См. также [раздел Как избежать преждевременной предварительной загрузки](odb_11.md#11_1_1_3).

### 11.1.3. Настройка выборки для фреймов данных

При извлечении фреймов данных с помощью `Connection.fetch_df_all()` или `Connection.fetch_df_batches()` настройка передачи данных по сети производится соответствующими параметрами этих методов `arraysize` или `size`.

Любое значение `oracledb.defaults.prefetchrows` игнорируется, поскольку эти методы всегда устанавливают внутренний размер предварительной выборки на соответствующее значение параметра `size` метода `arraysize`.

### 11.1.4. Распараллеливание выборки данных из одной таблицы

Прежде чем пытаться повысить производительность запросов к одной таблице путем выполнения нескольких запросов SELECT в нескольких потоках, где каждый запрос извлекает разный диапазон данных, следует провести тщательное сравнительное тестирование.

Факторы, которые повлияют на такое решение:

- Насколько загружена база данных? Параллельное решение может показаться быстрым, но оно может быть неэффективным, что негативно скажется на всех остальных процессах или в конечном итоге будет ограничено ими.

- Одно соединение python-oracledb может выполнять только одну операцию с базой данных одновременно, поэтому для каждого выполняемого SQL-запроса необходимо использовать отдельное соединение, например, используя соединения из [пула](odb_04.md#4_9). Это создаст дополнительную нагрузку на базу данных, которую необходимо оценить.

- Решение, использующее синтаксис OFFSET FETCH для выборки разделов таблицы в отдельных запросах, все равно приведет к сканированию блоков таблицы, даже если не все данные будут возвращены.

- Партиционирована ли таблица?

- Используются ли карты зон?

- Возможно, реальную проблему с производительностью невозможно решить с помощью параллелизма. Возможно, у вас есть индексы на основе функций, которые вызываются для каждой строки.

- Распределены ли данные в базе данных по нескольким дискам или поиск приходится на один диск?

- Используется ли Exadata для хранения?

- Каково влияние глобальной блокировки интерпретатора (GIL) в Python? Возможно, стоит использовать несколько процессов Python вместо потоков.

- Что приложение делает с данными? Может ли принимающая сторона эффективно их обработать?

- Лучше ли выполнить один запрос на Python, но использовать подсказку PARALLEL для запроса? Или это перегрузит базу данных?

## 11.2. "Круговые" обращения к базе данных

"Круговой" обход определяется как перемещение сообщения из python-oracledb в базу данных и обратно. Вызов каждой функции python-oracledb или доступ к каждому атрибуту потребует от нуля или более циклов. Например, вставка простой строки подразумевает отправку данных в базу данных и получение ответа об успешном выполнении. Это циклический обход. Наряду с настройкой архитектуры приложения и его [SQL-операторов](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=TGSQL), общей целью повышения производительности и масштабируемости является минимизация [циклов обхода](https://docs.oracle.com/en/database/oracle/oracle-database/26/lnoci/oci-function-server-round-trips.html#GUID-9B2F05F9-D841-4493-A42D-A7D89694A2D1), поскольку они влияют на производительность приложения и общую масштабируемость системы.

Вот несколько общих советов по сокращению количества обращений туда и обратно:

- Для каждого запроса SELECT настройте `Cursor.arraysize` и `Cursor.prefetchrows`.

- Для оптимального выполнения DML используйте `Cursor.executemany()`.

- Выполняйте коммит только при необходимости. Используйте `Connection.autocommit` в последнем операторе транзакции.

- Для пулов соединений используйте обратный вызов для установки состояния соединения, см. [раздел Обратные вызовы сеанса для установки состояния пула соединений](odb_04.md#4_9_6).

- Используйте процедуры PL/SQL, которые выполняют несколько операторов SQL, вместо того, чтобы выполнять их по отдельности из python-oracledb.

- Проверьте, можно ли использовать [конвейеризацию](odb_23.md#23_2).

- Используйте скалярные типы вместо объектных типов Oracle Database.

- Избегайте чрезмерного использования `Connection.ping()`.

- Избегайте установки для `ConnectionPool.ping_interval` значения `0` или меньшего значения.

- При использовании [SODA](odb_17.md) используйте объединенные соединения и включите [кэш метаданных SODA](odb_17.md#17_2).

### 11.2.1. Определение количества круговых поездок

Отчеты [AWR](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-56AEF38E-9400-427B-A818-EDEC145F7ACD) Oracle показывают «циклы SQL*Net к клиенту и от клиента» и полезны для определения общего поведения системы.

Иногда может потребоваться узнать количество циклов обработки, использованных для конкретного приложения. Для этого можно использовать снимки представления V$SESSTAT, сделанные до и после выполнения какой-либо задачи:

```
# Get the connection's session id
def get_session_id(connection):
    sql = "select sys_context('userenv','sid') from dual"
    result, = connection.cursor().execute(sql).fetchone()
    return result

 # Get the number of round-trips a session has made so far
 def get_round_trips(systemconn, sid):
     sql = """select
                  ss.value
              from
                  v$sesstat  ss,
                  v$statname sn
              where
                  ss.sid = :sid
                  and ss.statistic# = sn.statistic#
                  and sn.name like '%roundtrip%client%'"""
     round_trips, = systemconn.cursor().execute(sql, [sid]).fetchone()
     return round_trips

systemconn = oracledb.connect(user="system", password=spw, dsn=cs)
connection = oracledb.connect(user=un, password=pw, dsn=cs)

sid = get_session_id(connection)
round_trips_before = get_round_trips(systemconn, sid)

# Do some "work"
cursor.execute("select ...")
rows = cursor.fetchall()

round_trips_after = get_round_trips(systemconn, sid)

print(f"Round-trips required for query: {round_trips_after - round_trips_before}")
```

> Обратите внимание, что V$SESSTAT неточен для [конвейерных операций](odb_23.ms#23_2) с базой данных .

## 11.3 Кэширование операторов

Методы Python-oracledb `Cursor.execute()` и `Cursor.executemany()` используют кэширование операторов для повышения эффективности их повторного выполнения. Кэширование операторов позволяет использовать курсоры Oracle Database без повторного анализа операторов. Кэширование операторов также снижает затраты на передачу метаданных между python-oracledb и базой данных. Повышаются производительность и масштабируемость.

В режиме python-oracledb Thick используется кэширование операторов [Oracle Call Interface](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-4947CAE8-1F00-4897-BB2B-7F921E495175), тогда как в режиме Thin используется собственная реализация.

Каждое автономное или объединенное в пул соединение имеет собственный кэш операторов с размером по умолчанию 20. Размер кэша операторов по умолчанию можно изменить с помощью атрибута `oracledb.defaults.stmtcachesize`. Размер можно задать при создании пулов соединений или отдельных соединений. Как правило, размер кэша операторов следует устанавливать равным размеру рабочего набора операторов, выполняемых приложением. Чтобы вручную настроить кэш, отслеживайте общую нагрузку на приложение и значение «байты, отправленные клиенту через SQL*Net» из отчета AWR. Последняя статистика должна показать, что метаданные операторов не будут передаваться в python-oracledb. Отрегулируйте размер кэша операторов по своему усмотрению. В Oracle Database 12c (или более поздней версии) размер кэша операторов в режиме Thick можно автоматически настраивать с помощью файла `oraaccess.xml`.

### 11.3.1. Настройка кэша операторов

Размер кэша операторов можно задать глобально с помощью `oracledb.defaults.stmtcachesize`:

```
import oracledb

oracledb.defaults.stmtcachesize = 40
```

Значение можно переопределить в вызове `oracledb.connect()` или при создании пула с помощью `oracledb.create_pool()`. Например:

```
oracledb.create_pool(user="scott", password=userpwd, dsn="dbhost.example.com/orclpb",
                     min=2, max=5, increment=1, stmtcachesize=50)
```

Если в режиме Thick python-oracledb используется Oracle Client 21 (или более поздней версии), изменение размера кэша `ConnectionPool.reconfigure()` не влияет немедленно на ранее полученные и используемые в настоящее время соединения. При последующем освобождении этих соединений из пула и их повторном получении они будут использовать новое значение. Если в режиме Thick используется Oracle Client версии ниже 21, изменение размера кэша операторов пула не влияет на уже существующие соединения в пуле, но повлияет на новые соединения, создаваемые впоследствии, например, при увеличении пула.

### 11.3.2 Настройка кэша операторов

В общем случае установите размер кэша операторов равным размеру рабочего набора операторов, выполняемых приложением. [SODA](odb_17.md) выполняет внутренние SQL-вызовы, поэтому настройка кэша также полезна для приложений SODA.

В режиме python-oracledb Thick с клиентскими библиотеками Oracle 12c (или более поздними версиями) размер кэша операторов можно автоматически настроить с помощью файла конфигурации клиента Oracle `oraaccess.xml`.

Для ручной настройки используйте представления, такие как V$SYSSTAT:

```
SELECT value FROM V$SYSSTAT WHERE name = 'parse count (total)'
```

Найдите значение до и после загрузки приложения, чтобы определить количество разборов операторов во время нагрузочного теста. Измените размер кэша операторов и повторяйте тест, пока не найдете минимальное количество разборов.

Если у вас есть отчёты AWR, вы можете отслеживать общую нагрузку на приложение и значение «количество байтов, отправленных клиенту через SQL*Net». Последняя статистика должна улучшиться благодаря отсутствию отправки метаданных операторов в python-oracledb. Скорректируйте размер кэша операторов и повторите тест, чтобы найти оптимальный размер кэша.

### 11.3.3 Отключение кэширования выписок

Кэширование операторов можно отключить, установив размер кэша равным 0:

```
oracledb.defaults.stmtcachesize = 0
```

Отключение кэша может быть полезным, когда количество или порядок выполнения операторов приводит к очистке кэша до того, как он будет использован повторно. Например, если количество отдельных операторов превышает количество слотов кэша, а порядок выполнения операторов приводит к очистке старых операторов перед их повторным выполнением.

Отключение кэша операторов также может быть полезно в средах тестирования и разработки. Кэш операторов может стать недействительным, если соединения остаются открытыми, а объекты схемы базы данных создаются заново. В этом случае приложения могут получать ошибки, такие как ORA-3106. Однако после того, как ошибка выполнения оператора возвращается приложению, python-oracledb автоматически удаляет этот оператор из кэша. Это позволяет последующим повторным выполнениям оператора в этом соединении быть успешными.

Если передавать текст оператора через приложение неудобно, можно использовать метод `Cursor.prepare()` для предотвращения повторного анализа оператора. Если параметр `cache_statement` в методе `Cursor.prepare()` равен `True`, а размер кэша операторов больше `0`, операторы будут добавлены в кэш, если он ещё не существует. Если параметр `cache_statement` в методе `Cursor.prepare()` равен `False`, а размер кэша операторов больше 0, оператор будет удалён из кэша операторов (если он присутствует) или не будет кэширован (если он отсутствует). Последующие вызовы `execute()` используют значение `None` вместо текста SQL.

Эта функция может предотвратить очистку кэша потенциально более часто выполняемым оператором из-за редко выполняемого оператора. Например, если оператор будет выполнен только один раз:

```
cursor.prepare("select user from dual", cache_statement = False)
cursor.execute(None)
```

В качестве альтернативы,

```
sql = "select user from dual"
cursor.prepare(sql, cache_statement=False)
cursor.execute(sql)
```

Переданные `prepare()` операторы также сохраняются в кэше операторов.

## 11.4 Кэширование результатов на стороне клиента (CRC)

Приложения Python-oracledb могут использовать [клиентский кэш результатов](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-35CB2592-7588-4C2D-9075-6F639F25425E) Oracle Database. CRC обеспечивает кэширование результатов запроса SELECT на стороне клиента в клиентской памяти для немедленного использования при повторном выполнении того же запроса. Это полезно для снижения стоимости запросов к небольшим, преимущественно статическим, таблицам поиска, например, для почтовых индексов. CRC сокращает количество сетевых циклов и загрузку процессора сервера базы данных.

> **Примечание** \
> Кэширование результатов клиента поддерживается только в режиме python-oracledb Thick.

Кэширование осуществляется на уровне процесса приложения. Доступ к данным и их аннулирование управляются клиентскими библиотеками Oracle. Это устраняет необходимость в дополнительной логике приложения или внешних утилитах для реализации кэширования.

CRC можно включить, задав параметры базы данных `CLIENT_RESULT_CACHE_SIZE` и `CLIENT_RESULT_CACHE_LAG`, а затем перезапустив базу данных, например:

```
SQL> ALTER SYSTEM SET CLIENT_RESULT_CACHE_LAG = 3000 SCOPE=SPFILE;
SQL> ALTER SYSTEM SET CLIENT_RESULT_CACHE_SIZE = 64K SCOPE=SPFILE;
SQL> STARTUP FORCE
```

CRC также можно настроить в файле `oraaccess.xml` или `sqlnet.ora` на хосте Python, см. [раздел Параметры конфигурации клиента](https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-E63D75A1-FCAA-4A54-A3D2-B068442CE766).

Затем можно создавать или изменять таблицы, чтобы повторяющиеся запросы использовали CRC. Это позволяет существующим приложениям использовать CRC без необходимости внесения изменений. Например:

```
SQL> CREATE TABLE cities (id number, name varchar2(40)) RESULT_CACHE (MODE FORCE);
SQL> ALTER TABLE locations RESULT_CACHE (MODE FORCE);
```

В качестве альтернативы, подсказки можно использовать в операторах SQL. Например:

```
SELECT /*+ result_cache */ postal_code FROM locations
```
