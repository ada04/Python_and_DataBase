# under construction

# 11. Настройка python-oracledb
Вот несколько общих советов по настройке:

Настройте архитектуру вашего приложения.

Общая цель приложения — сократить количество обращений между python-oracledb и базой данных.

Для многопользовательских приложений используйте пул соединений. Создайте пул один раз при инициализации приложения. Не превышайте размер пула (см. раздел «Пул соединений») . Используйте функцию обратного вызова сеанса для установки состояния сеанса (см. раздел « Обратные вызовы сеанса для установки состояния пула соединений») .

Используйте эффективные функции python-oracledb. Например, для вставки нескольких строк используйте Cursor.executemany()вместо Cursor.execute(). В качестве альтернативы, Connection.direct_path_load()для вставки очень больших наборов данных используйте . Другой пример — извлечение данных непосредственно в виде фреймов данных вместо использования традиционного кода запроса при работе с такими пакетами, как Pandas и NumPy.

Настройте свои SQL-операторы. См. Руководство по настройке SQL .

Используйте переменные связывания , чтобы избежать повторного анализа операторов.

Настройте Cursor.arraysizeи Cursor.prefetchrowsдля каждого запроса SELECT см. раздел Настройка производительности выборки .

Выполните простые оптимизации, например ограничьте количество строк и избегайте выбора столбцов, не используемых в приложении.

Работать с простыми скалярными реляционными значениями может быть быстрее, чем использовать типы объектов Oracle Database.

Эффективно используйте PL/SQL, чтобы избежать выполнения множества отдельных операторов из python-oracledb.

Настройте кэш операторов .

Включить кэширование результатов клиента для небольших таблиц поиска.

Настройте свою базу данных. См. Руководство по настройке производительности базы данных .

Настройте сеть. Например, при вставке или извлечении большого количества строк (или больших объёмов данных) или при использовании медленной сети настройте размер блока данных сеанса Oracle Network (SDU) и буфера сокета. См. разделы « Настройка блока данных сеанса» и «Oracle Net Services: лучшие практики обеспечения производительности и высокой доступности баз данных» .

В режиме Thick python-oracledb размер SDU настраивается в дополнительных файлах конфигурации Oracle Net . В режиме Thin python-oracledb размер SDU может быть передан как параметр создания соединения или пула. В обоих режимах его можно дополнительно задать в строке Easy Connect соединения или в дескрипторе соединения . Фактически используемый размер SDU определяется по наименьшему из двух значений: значения на стороне приложения и значения конфигурации SDU сети базы данных.

Не фиксируйте и не откатывайте транзакции без необходимости. Используйте Connection.autocommit в конце последовательности операторов DML.

Рассмотрите возможность использования параллельного программирования или конвейеризации .

Если глобальная блокировка интерпретатора (GIL) Python ограничивает производительность параллельных программ, то рассмотрите возможность использования параллельных процессов Python.

11.1. Настройка производительности выборки
Для повышения производительности и масштабируемости приложения можно настроить Cursor.prefetchrowsи Cursor.arraysizeнастроить внутренние буферы python-oracledb, используемые для результатов запросов SELECT и REF CURSOR. Увеличение размеров приводит к выборке большего количества строк при каждом внутреннем запросе к базе данных. Это сокращает количество необходимых циклов передачи данных . Выигрыш в производительности от увеличения размера буфера может быть значительным при выборке большого количества строк или при использовании медленного сетевого соединения. База данных также выигрывает от снижения накладных расходов.

Внутренне python-oracledb всегда выполняет предварительную выборку строк и выборку массивов. Предварительная выборка строк происходит, когда строки возвращаются из базы данных в цикле, используемом для выполнения начального оператора. После этого строки доступны во внутреннем буфере для использования приложением. Без предварительной выборки первый набор строк пришлось бы извлекать из базы данных с помощью отдельного цикла. Когда все строки в буфере предварительной выборки будут использованы приложением, следующий набор строк извлекается в буфер с помощью выборки массива, которая занимает один цикл. Эти строки становятся доступны приложению по мере необходимости. После того, как начальный буфер выборки массива опустошается, дальнейшие выборки массива в буфер происходят по мере необходимости для полного извлечения всех строк из базы данных.

Изменение размеров буфера с помощью prefetchrowsи arraysizeвлияет на внутреннее поведение буферизации Cursor.fetchone(), Cursor.fetchmany(), и Cursor.fetchall(). Значения атрибутов не влияют на то, как строки возвращаются в приложение, за исключением Cursor.fetchmany(), где Cursor.arraysizeтакже используется в качестве значения по умолчанию для его size параметра.

Накладные расходы на предварительную выборку строк в режиме Thick в Python-Oracledb заключаются в использовании отдельного буфера, отличного от буфера выборки массива, что увеличивает требования к памяти. Кроме того, выполняется дополнительное копирование данных из буфера предварительной выборки клиента Oracle. В некоторых случаях эти затраты могут перевесить преимущества использования предварительной выборки.

Запросы SELECT, возвращающие объекты LOB и подобные типы, никогда не будут предварительно выбирать строки, поэтому prefetchrowsв этих случаях значение игнорируется.

Атрибуты не влияют на вставку данных. Чтобы сократить количество циклов выполнения операторов DML, см. разделы Пакетные операторы и операции массового копирования .

11.1.1 Выбор значений для arraysizeиprefetchrows
Настройте «выборку массива» с помощью Cursor.arraysize. Настройте «предварительную выборку строк» ​​с помощью Cursor.prefetchrows. Установите эти значения перед вызовом Cursor.execute(). См. также значения Application Default Prefetchrows и Arraysize .

Оптимальные значения arraysizeи prefetchrowsхарактеристики можно определить, проведя сравнительный анализ производительности приложения под производственной нагрузкой. Вот начальные рекомендации для четырёх распространённых сценариев:

Сценарий 1: Чтобы оптимизировать запросы, возвращающие неизвестное и большое количество строк, увеличивайте значение arraysizeпо умолчанию (100) до тех пор, пока не будете удовлетворены производительностью, объёмом памяти и использованием циклов передачи данных. Например:

cursor = connection.cursor()

# cursor.prefetchrows = 2  # generally leave this at its default
cursor.arraysize = 1000

for row in cursor.execute("select * from very_big_table"):
    print(row)
В этом случае, как правило, оставляйте prefetchrowsзначение по умолчанию. Если вы всё же решите изменить его, установите Cursor.arraysizeбольшее значение. Не делайте размеры слишком большими без необходимости.

Сценарий 2: Если вы извлекаете фиксированное количество строк, установите значение, равное arraysizeожидаемому количеству строк, и значение, prefetchrowsна единицу больше этого значения. Добавление единицы устраняет необходимость в циклическом запросе для проверки конца выборки. Например, если вы используете запрос SELECT для извлечения 20 строк, например, для отображения страницы данных, установите prefetchrowsзначения 21 и arraysize20:

cursor = connection.cursor()

cursor.prefetchrows = 21
cursor.arraysize = 20

for row in cursor.execute("""
    select last_name
       from employees
       order by last_name
       offset 0 rows fetch next 20 rows only"""):
    print(row)
Это вернет все строки запроса за один цикл.

Сценарий 3: Если количество строк, возвращаемых оператором SELECT в вашем приложении, варьируется от выполнения к выполнению, но никогда не бывает большим, вы можете использовать стратегию, аналогичную сценарию 2.

Выберите arraysizeзначения prefetchrows, которые хорошо подходят для ожидаемого максимального количества строк.

Сценарий 4: Если вы знаете, что запрос SELECT возвращает только одну строку, установите arraysizeзначение 1, чтобы минимизировать использование памяти. Значение prefetch по умолчанию, равное 2, обеспечивает минимальное количество циклов обработки для однострочных запросов:

cursor = connection.cursor()

cursor.arraysize = 1

cursor.execute("select * from MyTable where id = 1"):
row = cursor.fetchone()
print(row)
Для извлечения строк требуются циклические запросы

В следующей таблице показано количество циклов, необходимых для выборки различного количества строк с разными значениями prefetchrowsи .arraysize

Таблица 11.1 Влияние количества поездок prefetchrowsтуда и обратно на их количествоarraysize
Количество рядов

prefetchrows

arraysize

Круговые поездки

1

2

100

1

100

2

100

2

1000

2

100

11

10000

2

100

101

10000

2

1000

11

10000

1000

1000

11

20

20

20

2

20

21

20

1

Количество циклов будет одинаковым независимо от того, какой метод python-oracledb используется для получения результатов запроса.

11.1.1.1. Значения prefetchrows и Arraysize приложения по умолчанию
Настройки по умолчанию для всего приложения можно задать с помощью oracledb.defaults.prefetchrowsи oracledb.defaults.arraysize, например:

import oracledb

oracledb.defaults.prefetchrows = 1000
oracledb.defaults.arraysize    = 1000
При использовании python-oracledb в режиме Thick предварительную выборку также можно настроить во внешнем файле oraaccess.xml , что может быть полезно для настройки приложения, когда изменение его кода невозможно.

Настройка размеров с помощью oracledb.defaultsатрибутов или с помощью oraaccess.xmlповлияет на все приложение, поэтому это не должно быть первым выбором при настройке.

11.1.1.2. Изменение строк предварительной выборки и размера массива для повторно выполняемых операторов
В python-oracledb значения prefetchrowsи arraysizeпроверяются только при первом выполнении оператора. Чтобы изменить значения для повторно выполняемого оператора, создайте новый курсор. Например, чтобы изменить arraysize:

array_sizes = (10, 100, 1000)
for size in array_sizes:
    cursor = connection.cursor()
    cursor.arraysize = size
    start = time.time()
    cursor.execute(sql).fetchall()
    elapsed = time.time() - start
    print("Time for", size, elapsed, "seconds")
11.1.1.3. Предотвращение преждевременной предварительной загрузки
Есть два случая, когда полезно установить значение prefetchrows на ноль:

При передаче курсора python-oracledb в PL/SQL. Установка prefetchrowsзначения 0 может предотвратить преждевременную (и скрытую) загрузку строк во внутренний буфер python-oracledb, делая эти строки недоступными для параметра REF CURSOR PL/SQL:

refcursor = connection.cursor()
refcursor.prefetchrows = 0
refcursor.execute("select ...")
cursor.callproc("myproc", [refcursor])
При запросе функции PL/SQL, которая использует PIPE ROW для периодической выдачи строк. По умолчанию функция должна выдать несколько строк, прежде чем python-oracledb сможет вернуть их приложению. Установка prefetchrowsзначения 0 обеспечивает равномерную передачу данных в приложение.

11.1.2. Настройка выборки из REF CURSORS
Внутреннюю буферизацию и производительность выборки данных из REF CURSORS можно настроить, установив значение arraysizeдо выборки строк из курсора. При выборке из REF CURSORS это prefetchrowsзначение игнорируется .

Например:

ref_cursor = connection.cursor()
cursor.callproc("myrefcursorproc", [ref_cursor])

ref_cursor.arraysize = 1000
print("Sum of IntCol for", num_rows, "rows:")
for row in ref_cursor:
    sum_rows += row[0]
print(sum_rows)
Значение Cursor.arraysize`также можно установить перед вызовом процедуры:

ref_cursor = connection.cursor()
ref_cursor.arraysize = 1000

cursor.callproc("myrefcursorproc", [ref_cursor])
for row in ref_cursor:
    . . .
См. также раздел Как избежать преждевременной предварительной загрузки .

11.1.3. Настройка выборки для фреймов данных
При извлечении кадров данных с помощью Connection.fetch_df_all()или Connection.fetch_df_batches()настройка передачи данных по сети контролируется соответствующими методами arraysizeили sizeпараметрами.

Любое oracledb.defaults.prefetchrowsзначение игнорируется, поскольку эти методы всегда устанавливают внутренний размер предварительной выборки на соответствующее arraysizeзначение size.

11.1.4. Распараллеливание выборки данных из одной таблицы
Прежде чем пытаться повысить производительность запросов к одной таблице путем выполнения нескольких запросов SELECT в нескольких потоках, где каждый запрос извлекает разный диапазон данных, следует провести тщательное сравнительное тестирование.

Факторы, которые повлияют на такое решение:

Насколько загружена база данных? Параллельное решение может показаться быстрым, но оно может быть неэффективным, что негативно скажется на всех остальных процессах или в конечном итоге будет ограничено ими.

Одно соединение python-oracledb может выполнять только одну операцию с базой данных одновременно, поэтому для каждого выполняемого SQL-запроса необходимо использовать отдельное соединение, например, используя соединения из пула . Это создаст дополнительную нагрузку на базу данных, которую необходимо оценить.

Наивное решение, использующее синтаксис OFFSET FETCH для выборки разделов таблицы в отдельных запросах, все равно приведет к сканированию блоков таблицы, даже если не все данные будут возвращены.

Разделена ли таблица?

Используются ли карты зон?

Возможно, реальную проблему с производительностью невозможно решить с помощью параллелизма. Возможно, у вас есть индексы на основе функций, которые вызываются для каждой строки.

Распределены ли данные в базе данных по нескольким шпинделям или поиск приходится на один диск?

Используется ли Exadata с индексами хранения?

Каково влияние глобальной блокировки интерпретатора (GIL) в Python? Возможно, стоит использовать несколько процессов Python вместо потоков.

Что приложение делает с данными? Может ли принимающая сторона эффективно их обработать?

Лучше ли выполнить один запрос на Python, но использовать подсказку PARALLEL для запроса? Или это перегрузит базу данных?

11.2. Круговые обращения к базе данных
Круговой обход определяется как перемещение сообщения из python-oracledb в базу данных и обратно. Вызов каждой функции python-oracledb или доступ к каждому атрибуту потребует от нуля или более циклов. Например, вставка простой строки подразумевает отправку данных в базу данных и получение ответа об успешном выполнении. Это циклический обход. Наряду с настройкой архитектуры приложения и его SQL-операторов , общей целью повышения производительности и масштабируемости является минимизация циклов обхода, поскольку они влияют на производительность приложения и общую масштабируемость системы.

Вот несколько общих советов по сокращению количества поездок туда и обратно:

Настройте Cursor.arraysizeи Cursor.prefetchrowsдля каждого запроса SELECT.

Используйте Cursor.executemany()для оптимального выполнения DML.

Выполняйте фиксацию только при необходимости. Используйте Connection.autocommitв последнем операторе транзакции.

Для пулов соединений используйте обратный вызов для установки состояния соединения, см. раздел Обратные вызовы сеанса для установки состояния пула соединений .

Используйте процедуры PL/SQL, которые выполняют несколько операторов SQL, вместо того, чтобы выполнять их по отдельности из python-oracledb.

Проверьте, можно ли использовать конвейеризацию .

Используйте скалярные типы вместо типов объектов Oracle Database.

Избегайте чрезмерного использования Connection.ping().

Избегайте установки ConnectionPool.ping_intervalзначения 0 или меньшего значения.

При использовании SODA используйте объединенные соединения и включите кэш метаданных SODA .

11.2.1. Определение количества круговых поездок
Отчеты автоматического репозитория рабочей нагрузки (AWR) Oracle показывают «циклы SQL*Net к клиенту и от клиента» и полезны для определения общего поведения системы.

Иногда может потребоваться узнать количество циклов обработки, использованных для конкретного приложения. Для этого можно использовать снимки представления V$SESSTAT, сделанные до и после выполнения какой-либо задачи:

# Get the connection's session id
def get_session_id(connection):
    sql = "select sys_context('userenv','sid') from dual"
    result, = connection.cursor().execute(sql).fetchone()
    return result

 # Get the number of round-trips a session has made so far
 def get_round_trips(systemconn, sid):
     sql = """select
                  ss.value
              from
                  v$sesstat  ss,
                  v$statname sn
              where
                  ss.sid = :sid
                  and ss.statistic# = sn.statistic#
                  and sn.name like '%roundtrip%client%'"""
     round_trips, = systemconn.cursor().execute(sql, [sid]).fetchone()
     return round_trips


systemconn = oracledb.connect(user="system", password=spw, dsn=cs)
connection = oracledb.connect(user=un, password=pw, dsn=cs)

sid = get_session_id(connection)
round_trips_before = get_round_trips(systemconn, sid)

# Do some "work"
cursor.execute("select ...")
rows = cursor.fetchall()

round_trips_after = get_round_trips(systemconn, sid)

print(f"Round-trips required for query: {round_trips_after - round_trips_before}")
Обратите внимание, что V$SESSTAT неточен для конвейерных операций с базой данных .

11.3 Кэширование операторов
Cursor.execute()Методы и операторы Python-oracledb Cursor.executemany() используют кэширование операторов для повышения эффективности их повторного выполнения. Кэширование операторов позволяет использовать курсоры Oracle Database без повторного анализа операторов. Кэширование операторов также снижает затраты на передачу метаданных между python-oracledb и базой данных. Повышаются производительность и масштабируемость.

В режиме python-oracledb Thick используется кэширование операторов Oracle Call Interface , тогда как в режиме Thin используется собственная реализация.

Каждое автономное или объединенное в пул соединение имеет собственный кэш операторов с размером по умолчанию 20. Размер кэша операторов по умолчанию можно изменить с помощью атрибута oracledb.defaults.stmtcachesize . Размер можно задать при создании пулов соединений или отдельных соединений. Как правило, размер кэша операторов следует устанавливать равным размеру рабочего набора операторов, выполняемых приложением. Чтобы вручную настроить кэш, отслеживайте общую нагрузку на приложение и значения автоматического репозитория рабочей нагрузки (AWR) «байты, отправленные клиенту через SQL*Net». Последняя статистика должна выиграть от того, что метаданные операторов не будут передаваться в python-oracledb. Отрегулируйте размер кэша операторов по своему усмотрению. В Oracle Database 12c (или более поздней версии) размер кэша операторов в режиме Thick можно автоматически настраивать с помощью файла oraaccess.xml .

11.3.1. Настройка кэша операторов
Размер кэша операторов можно задать глобально с помощью oracledb.defaults.stmtcachesize:

import oracledb

oracledb.defaults.stmtcachesize = 40
Значение можно переопределить в oracledb.connect()вызове или при создании пула с помощью oracledb.create_pool(). Например:

oracledb.create_pool(user="scott", password=userpwd, dsn="dbhost.example.com/orclpb",
                     min=2, max=5, increment=1, stmtcachesize=50)
Если в режиме Thick python-oracledb используется Oracle Client 21 (или более поздней версии), изменение размера кэша ConnectionPool.reconfigure()не влияет немедленно на ранее полученные и используемые в настоящее время соединения. При последующем освобождении этих соединений из пула и их повторном получении они будут использовать новое значение. Если в режиме Thick используется Oracle Client версии ниже 21, изменение размера кэша операторов пула не влияет на уже существующие соединения в пуле, но повлияет на новые соединения, создаваемые впоследствии, например, при увеличении пула.

11.3.2 Настройка кэша операторов
В общем случае установите размер кэша операторов равным размеру рабочего набора операторов, выполняемых приложением. SODA выполняет внутренние SQL-вызовы, поэтому настройка кэша также полезна для приложений SODA.

В режиме python-oracledb Thick с клиентскими библиотеками Oracle 12c (или более поздними версиями) размер кэша операторов можно автоматически настроить с помощью файла конфигурации клиента Oracle oraaccess.xml .

Для ручной настройки используйте представления, такие как V$SYSSTAT:

SELECT value FROM V$SYSSTAT WHERE name = 'parse count (total)'
Найдите значение до и после загрузки приложения, чтобы определить количество разборов операторов во время нагрузочного теста. Измените размер кэша операторов и повторяйте тест, пока не найдете минимальное количество разборов.

Если у вас есть отчёты автоматического репозитория рабочей нагрузки (AWR), вы можете отслеживать общую нагрузку на приложение и значения «количество байтов, отправленных клиенту через SQL*Net». Последняя статистика должна улучшиться благодаря отсутствию отправки метаданных операторов в python-oracledb. Скорректируйте размер кэша операторов и повторите тест, чтобы найти оптимальный размер кэша.

11.3.3 Отключение кэширования выписок
Кэширование операторов можно отключить, установив размер кэша равным 0:

oracledb.defaults.stmtcachesize = 0
Отключение кэша может быть полезным, когда количество или порядок выполнения операторов приводит к очистке кэша до того, как он будет использован повторно. Например, если количество отдельных операторов превышает количество слотов кэша, а порядок выполнения операторов приводит к очистке старых операторов перед их повторным выполнением.

Отключение кэша операторов также может быть полезно в средах тестирования и разработки. Кэш операторов может стать недействительным, если соединения остаются открытыми, а объекты схемы базы данных создаются заново. В этом случае приложения могут получать ошибки, такие как ORA-3106. Однако после того, как ошибка выполнения оператора возвращается приложению, python-oracledb автоматически удаляет этот оператор из кэша. Это позволяет последующим повторным выполнениям оператора в этом соединении быть успешными.

Если передавать текст оператора через приложение неудобно, этот Cursor.prepare()вызов можно использовать для предотвращения повторного анализа оператора. Если cache_statementпараметр в Cursor.prepare()методе равен True, а размер кэша операторов больше 0, операторы будут добавлены в кэш, если он ещё не существует. Если параметр cache_statement в Cursor.prepare()методе равен False, а размер кэша операторов больше 0, оператор будет удалён из кэша операторов (если он присутствует) или не будет кэширован (если он отсутствует). Последующие execute()вызовы используют значение None вместо текста SQL.

Эта функция может предотвратить очистку кэша потенциально более часто выполняемым оператором из-за редко выполняемого оператора. Например, если оператор будет выполнен только один раз:

cursor.prepare("select user from dual", cache_statement = False)
cursor.execute(None)
В качестве альтернативы,

sql = "select user from dual"
cursor.prepare(sql, cache_statement=False)
cursor.execute(sql)
Переданные операторы prepare()также сохраняются в кэше операторов.

11.4 Кэширование результатов клиента (CRC)
Приложения Python-oracledb могут использовать клиентский кэш результатов Oracle Database . CRC обеспечивает кэширование результатов запроса SELECT на стороне клиента в клиентской памяти для немедленного использования при повторном выполнении того же запроса. Это полезно для снижения стоимости запросов к небольшим, преимущественно статическим, таблицам поиска, например, для почтовых индексов. CRC сокращает количество сетевых циклов и загрузку процессора сервера базы данных.

Примечание

Кэширование результатов клиента поддерживается только в режиме python-oracledb Thick. См. раздел Включение режима python-oracledb Thick .

Кэширование осуществляется на уровне процесса приложения. Доступ к данным и их аннулирование управляются клиентскими библиотеками Oracle. Это устраняет необходимость в дополнительной логике приложения или внешних утилитах для реализации кэширования.

CRC можно включить, задав параметры базы данных CLIENT_RESULT_CACHE_SIZE и CLIENT_RESULT_CACHE_LAG, а затем перезапустив базу данных, например:

SQL> ALTER SYSTEM SET CLIENT_RESULT_CACHE_LAG = 3000 SCOPE=SPFILE;
SQL> ALTER SYSTEM SET CLIENT_RESULT_CACHE_SIZE = 64K SCOPE=SPFILE;
SQL> STARTUP FORCE
CRC также можно настроить в файле oraaccess.xml или sqlnet.ora на хосте Python, см. раздел Параметры конфигурации клиента .

Затем можно создавать или изменять таблицы, чтобы повторяющиеся запросы использовали CRC. Это позволяет существующим приложениям использовать CRC без необходимости внесения изменений. Например:

SQL> CREATE TABLE cities (id number, name varchar2(40)) RESULT_CACHE (MODE FORCE);
SQL> ALTER TABLE locations RESULT_CACHE (MODE FORCE);
В качестве альтернативы, подсказки можно использовать в операторах SQL. Например:

SELECT /*+ result_cache */ postal_code FROM locations
